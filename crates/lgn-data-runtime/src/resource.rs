use std::any::{Any, TypeId};
use std::collections::HashMap;
use std::convert::TryFrom;
use std::path::PathBuf;
use std::sync::RwLock;
use std::{fmt, hash::Hash, str::FromStr};

use lgn_data_model::TypeReflection;
use lgn_utils::DefaultHash;
use once_cell::sync::OnceCell;
use serde::ser::SerializeTuple;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::fmt::Write;
use uuid::Uuid;
use xxhash_rust::const_xxh3::xxh3_64 as const_xxh3;

/// Type identifier of resource or asset.
///
/// It is currently generated by hashing the name of a type, into a stable
/// 64-bits value.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ResourceType(std::num::NonZeroU64);

impl fmt::Display for ResourceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("{:016x}", self.0))
    }
}
impl fmt::Debug for ResourceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("ResourceType")
            .field(&format_args!("{:#016x}", self.0))
            .finish()
    }
}

static RESOURCE_TYPE_MAPPING: OnceCell<RwLock<HashMap<ResourceType, &'static str>>> =
    OnceCell::new();

impl ResourceType {
    /// Creates a new type id from series of bytes.
    ///
    /// It is recommended to use this method to define a public constant
    /// which can be used to identify a resource or asset.
    pub const fn new(v: &[u8]) -> Self {
        Self::from_raw(const_xxh3(v))
    }

    /// Creates a type id from a non-zero integer.
    pub const fn from_raw(v: u64) -> Self {
        let v = match std::num::NonZeroU64::new(v) {
            Some(v) => v,
            None => panic!(),
        };
        Self(v)
    }

    /// Return the name of the `ResourceType`
    pub fn as_pretty(self) -> &'static str {
        let name_mapping = RESOURCE_TYPE_MAPPING.get_or_init(|| RwLock::new(HashMap::new()));
        if let Some(value) = name_mapping.read().unwrap().get(&self) {
            *value
        } else {
            "unknown"
        }
    }

    /// Registry a name for a `ResourceType`
    pub fn register_name(id: Self, name: &'static str) {
        let name_mapping = RESOURCE_TYPE_MAPPING.get_or_init(|| RwLock::new(HashMap::new()));
        name_mapping.write().unwrap().insert(id, name);
    }
}

impl Serialize for ResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if serializer.is_human_readable() {
            let bytes = self.0.get().to_be_bytes();
            let hex = hex::encode(bytes);
            serializer.serialize_str(&hex)
        } else {
            serializer.serialize_u64(self.0.get())
        }
    }
}

impl<'de> Deserialize<'de> for ResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        use serde::de::Error;

        let v = {
            if deserializer.is_human_readable() {
                let hex = String::deserialize(deserializer)?;
                let digits = hex::decode(hex).map_err(D::Error::custom)?;
                u64::from_be_bytes(digits.try_into().unwrap())
            } else {
                u64::deserialize(deserializer)?
            }
        };
        Ok(Self::from_raw(v))
    }
}

impl FromStr for ResourceType {
    type Err = std::num::ParseIntError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let v = u64::from_str_radix(s, 16)?;
        if v == 0 {
            Err("Z".parse::<u64>().expect_err("ParseIntError"))
        } else {
            Ok(Self::from_raw(v))
        }
    }
}

/// Id of a runtime asset or source or derived resource.
///
/// We currently use fully random 128-bit UUIDs, to ensure uniqueness without
/// requiring a central authority. This allows creation of two `ResourceId` on
/// two separate machines and guarantee that we won't have any collision when
/// submitting those Resources on the source control.
#[derive(Clone, Copy, PartialEq, PartialOrd, Ord, Eq, Debug, Hash)]
pub struct ResourceId(std::num::NonZeroU128);

impl ResourceId {
    /// Creates a new random id.
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        Self(std::num::NonZeroU128::new(Uuid::new_v4().as_u128()).unwrap())
    }
    /// Creates an explicit id, assuming that it is a runtime counter, not for
    /// serialization. The UUID 'version' is a non-standard value of 15.
    pub fn new_explicit(id: u64) -> Self {
        Self(
            std::num::NonZeroU128::new(
                uuid::Builder::from_u128(u128::from(id))
                    .set_version(unsafe { std::mem::transmute(0xF_u8) })
                    .as_uuid()
                    .as_u128(),
            )
            .unwrap(),
        )
    }

    /// Initialize from an existing, serialized, source.
    pub fn from_raw(id: u128) -> Self {
        Self(std::num::NonZeroU128::new(id).unwrap())
    }

    /// Initialize by hashing the contents of an object. We set 'Sha1' as UUID
    /// version even if our hash isn't really SHA-1.
    pub fn from_obj<T: Hash>(obj: &T) -> Self {
        let id = (*obj).default_hash_128();
        Self(
            std::num::NonZeroU128::new(
                uuid::Builder::from_u128(id)
                    .set_version(uuid::Version::Sha1)
                    .as_uuid()
                    .as_u128(),
            )
            .unwrap(),
        )
    }

    /// Returns a path of a resource.
    pub fn resource_path(&self) -> PathBuf {
        PathBuf::from(self)
    }
}

impl fmt::Display for ResourceId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("{}", Uuid::from_u128(self.0.get())))
    }
}

impl FromStr for ResourceId {
    type Err = Box<dyn std::error::Error>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let id = Uuid::from_str(s)?;
        Ok(Self::from_raw(id.as_u128()))
    }
}

impl TryFrom<u128> for ResourceId {
    type Error = ();

    fn try_from(value: u128) -> Result<Self, Self::Error> {
        Ok(Self::from_raw(value))
    }
}

impl From<&ResourceId> for PathBuf {
    fn from(id: &ResourceId) -> Self {
        let mut path = Self::new();
        let mut byte_text = String::with_capacity(2);
        for byte in id.0.get().to_be_bytes().into_iter().take(3) {
            write!(byte_text, "{:02x}", byte).unwrap();
            path.push(&byte_text);
            byte_text.clear();
        }
        path.push(id.to_string());
        path
    }
}

impl Serialize for ResourceId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if serializer.is_human_readable() {
            let id = Uuid::from_u128(self.0.get()).to_string();
            serializer.serialize_str(&id)
        } else {
            serializer.serialize_u128(self.0.get())
        }
    }
}

impl<'de> Deserialize<'de> for ResourceId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let id = {
            if deserializer.is_human_readable() {
                let id = String::deserialize(deserializer)?;
                Uuid::from_str(&id).unwrap().as_u128()
            } else {
                u128::deserialize(deserializer)?
            }
        };
        Ok(Self::from_raw(id))
    }
}

/// FIXME: This should only be a temporary struct, we should be using the
/// `ResourceId` directly.
#[derive(Clone, Copy, PartialEq, PartialOrd, Ord, Eq, Hash)]
pub struct ResourceTypeAndId {
    /// The associated `ResourceType`.
    pub kind: ResourceType,

    /// The associated `ResourceId`.
    pub id: ResourceId,
}

impl FromStr for ResourceTypeAndId {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut pair = s.trim_matches(|p| p == '(' || p == ')').split(',');
        let kind = pair
            .next()
            .ok_or("missing kind")?
            .parse::<ResourceType>()
            .map_err(|_err| "invalid resourcetype")?;
        let id = pair
            .next()
            .ok_or("missing id")?
            .parse::<ResourceId>()
            .map_err(|_err| "invalid resourceid")?;
        Ok(Self { kind, id })
    }
}

impl fmt::Display for ResourceTypeAndId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("({},{})", self.kind, self.id))
    }
}

impl fmt::Debug for ResourceTypeAndId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("({},{})", self.kind.as_pretty(), self.id))
    }
}

impl Serialize for ResourceTypeAndId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if serializer.is_human_readable() {
            serializer.serialize_str(&format!("{}", self))
        } else {
            let mut tup = serializer.serialize_tuple(2)?;
            tup.serialize_element(&self.kind)?;
            tup.serialize_element(&self.id)?;
            tup.end()
        }
    }
}

impl<'de> Deserialize<'de> for ResourceTypeAndId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        if deserializer.is_human_readable() {
            let kind_id = String::deserialize(deserializer)?;
            Ok(Self::from_str(&kind_id).unwrap())
        } else {
            let (kind, id) = <(ResourceType, ResourceId)>::deserialize(deserializer)?;
            Ok(Self { kind, id })
        }
    }
}

/// Trait describing resource type name.
pub trait ResourceDescriptor {
    /// Name of the asset type.
    const TYPENAME: &'static str;
    /// Type of the asset.
    const TYPE: ResourceType = ResourceType::new(Self::TYPENAME.as_bytes());
}

/// Trait describing a resource
pub trait Resource: TypeReflection + Any + Send + Sync {
    /// Return the `Resource` as a reflected type
    fn as_reflect(&self) -> &dyn TypeReflection;

    /// Return the `Resource` as a reflected type
    fn as_reflect_mut(&mut self) -> &mut dyn TypeReflection;

    /// Return a shallow clone of the Resource
    fn clone_dyn(&self) -> Box<dyn Resource>;
}

/// Note: Based on impl of dyn Any
impl dyn Resource {
    /// Returns `true` if the boxed type is the same as `T`.
    /// (See [`std::any::Any::is`](https://doc.rust-lang.org/std/any/trait.Any.html#method.is))
    #[inline]
    pub fn is<T: Resource>(&self) -> bool {
        TypeId::of::<T>() == self.type_id()
    }

    /// Returns some reference to the boxed value if it is of type `T`, or
    #[inline]
    pub fn downcast_ref<T: Resource>(&self) -> Option<&T> {
        if self.is::<T>() {
            #[allow(unsafe_code)]
            unsafe {
                Some(&*((self as *const dyn Resource).cast::<T>()))
            }
        } else {
            None
        }
    }

    /// Returns some reference to the boxed value if it is of type `T`, or
    #[inline]
    pub fn downcast_mut<T: Resource>(&mut self) -> Option<&mut T> {
        if self.is::<T>() {
            #[allow(unsafe_code)]
            unsafe {
                Some(&mut *((self as *mut dyn Resource).cast::<T>()))
            }
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use std::{ffi::OsStr, path::PathBuf, str::FromStr};

    use crate::ResourceId;

    #[test]
    fn resource_path() {
        let text = "986a4ba3-d1d0-43ca-9051-56d26ad421ad";
        let id = ResourceId::from_str(text).expect("valid uuid");
        let path: PathBuf = id.resource_path();

        let mut iter = path.iter();
        assert_eq!(iter.next(), Some(OsStr::new("98")));
        assert_eq!(iter.next(), Some(OsStr::new("6a")));
        assert_eq!(iter.next(), Some(OsStr::new("4b")));
        assert_eq!(
            iter.next(),
            Some(OsStr::new("986a4ba3-d1d0-43ca-9051-56d26ad421ad"))
        );
        assert_eq!(iter.next(), None);
    }
}
