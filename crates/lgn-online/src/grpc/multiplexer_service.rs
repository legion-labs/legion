use std::{
    collections::HashMap,
    task::{Context, Poll},
};

use dyn_clone::DynClone;
use http::{Request, Response, StatusCode};
use lgn_tracing::{debug, info};
use tonic::{
    body::BoxBody,
    codegen::{BoxFuture, StdError},
    transport::NamedService,
};

use super::{Error, Result};

pub trait MultiplexableService: DynClone {
    fn call(&mut self, req: Request<hyper::Body>) -> BoxFuture<Response<BoxBody>, Error>;
}

dyn_clone::clone_trait_object!(MultiplexableService);

/// Blanket implementation for all services: makes it possible to use all
/// tonic-generated services in the `Multiplexer` service.
impl<S> MultiplexableService for S
where
    S: tower::Service<Request<hyper::Body>, Response = Response<BoxBody>> + Clone,
    S::Error: Into<StdError>,
    S::Future: Send + 'static,
{
    fn call(&mut self, req: Request<hyper::Body>) -> BoxFuture<Response<BoxBody>, Error> {
        let fut = S::call(self, req);

        Box::pin(async move { fut.await.map_err(Into::into).map_err(Error::Other) })
    }
}

type BoxMultiplexableService = Box<dyn MultiplexableService + Send + Sync>;

#[derive(Default, Clone)]
struct Services(HashMap<&'static str, BoxMultiplexableService>);

impl Services {
    fn new() -> Self {
        Self(HashMap::new())
    }

    fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    fn get_mut(&mut self, svc_name: &str) -> Option<&mut BoxMultiplexableService> {
        self.0.get_mut(svc_name)
    }

    fn add_service<S>(&mut self, s: S)
    where
        S: MultiplexableService + NamedService + Send + Sync + 'static,
    {
        self.0.insert(S::NAME, Box::new(s));
    }
}

/// A helper type to construct `MultiplexerService` instances.
#[derive(Default, Clone)]
pub struct MultiplexerServiceBuilder {
    services: Services,
}

impl MultiplexerServiceBuilder {
    fn new() -> Self {
        Self {
            services: Services::new(),
        }
    }

    /// Add a `gRPC` service to route traffic to.
    ///
    /// This call expects a service as generated by the `tonic` crate.
    pub fn add_service<S>(&mut self, s: S) -> &mut Self
    where
        S: MultiplexableService + NamedService + Send + Sync + 'static,
    {
        info!("registered service `{}`", S::NAME);

        self.services.add_service(s);

        self
    }

    /// Build a `MultiplexerService` only if it has at least one service to
    /// route traffic to.
    pub fn build(&self) -> Option<MultiplexerService> {
        if self.services.is_empty() {
            None
        } else {
            Some(MultiplexerService::new(self.services.clone()))
        }
    }
}

/// Multiplexer is a routing service that can dynamically be extended with new
/// `gRPC` services at runtime.
#[derive(Default, Clone)]
pub struct MultiplexerService {
    services: Services,
}

impl MultiplexerService {
    pub fn builder() -> MultiplexerServiceBuilder {
        MultiplexerServiceBuilder::new()
    }

    fn new(services: Services) -> Self {
        Self { services }
    }

    fn not_found() -> BoxFuture<Response<BoxBody>, Error> {
        Self::failure(http::StatusCode::NOT_FOUND)
    }

    fn failure(status: StatusCode) -> BoxFuture<Response<BoxBody>, Error> {
        Box::pin(async move {
            http::Response::builder()
                .status(status)
                .body(tonic::body::empty_body())
                .map_err(Into::into)
                .map_err(Error::Other)
        })
    }
}

impl tower::Service<Request<hyper::Body>> for MultiplexerService {
    type Response = Response<BoxBody>;
    type Error = Error;
    type Future = BoxFuture<Self::Response, Self::Error>;

    fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<()>> {
        Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: Request<hyper::Body>) -> Self::Future {
        if let Some(content_type) = req.headers().get("content-type") {
            let content_type = content_type.to_str().unwrap_or_default();

            if content_type.starts_with("application/grpc") {
                if let Some(svc_name) = req.uri().path().split('/').nth(1) {
                    match &mut self.services.get_mut(svc_name) {
                        Some(svc) => {
                            debug!("dispatching call to service `{}`", svc_name);

                            svc.call(req)
                        }
                        None => {
                            debug!(
                                "cannot dispatch call to unregistered service `{}`",
                                svc_name
                            );

                            Self::not_found()
                        }
                    }
                } else {
                    debug!(
                        "failed to dispatch call to service: the request path does not seem to contain a service name ({})",
                        req.uri().path(),
                    );

                    Self::not_found()
                }
            } else {
                debug!(
                    "rejecting HTTP call with no gRPC content-type `{}`",
                    content_type,
                );

                Self::failure(StatusCode::UNSUPPORTED_MEDIA_TYPE)
            }
        } else {
            debug!("rejecting HTTP call with no content-type specified");

            Self::failure(StatusCode::BAD_REQUEST)
        }
    }
}

impl NamedService for MultiplexerService {
    const NAME: &'static str = "";
}
