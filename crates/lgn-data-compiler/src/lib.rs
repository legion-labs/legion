//! A crate with modules supporting data compilation process.
//!
//! * [`compiler_api`] provides an interface for implementing a data compiler.
//! * [`compiler_cmd`] provides utilities for interacting with data compilers.

// crate-specific lint exceptions:
#![allow(unsafe_code, clippy::missing_errors_doc)]
#![warn(missing_docs)]

use core::fmt;
use std::str::FromStr;

use lgn_content_store::Checksum;
use lgn_data_offline::ResourcePathId;
use serde::{Deserialize, Serialize};

/// Identifies a group of outputs generated by the data compiler.
#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize, Hash)]
pub struct CompilerHash(pub u64);

/// Description of a compiled resource.
#[derive(Debug, PartialEq, Eq, Serialize, Deserialize, Clone)]
pub struct CompiledResource {
    /// The path of derived resource.
    pub path: ResourcePathId,
    /// The checksum of the resource.
    pub checksum: Checksum,
    /// The size of the resource.
    pub size: usize,
}

impl fmt::Display for CompiledResource {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "{}-{}-{}",
            self.checksum, self.size, self.path
        ))
    }
}

impl FromStr for CompiledResource {
    type Err = Box<dyn std::error::Error>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let err = "Z".parse::<i32>().expect_err("ParseIntError");
        let mut iter = s.split(|c| c == '-');

        let checksum = Checksum::from_str(iter.next().ok_or_else(|| err.clone())?)?;
        let size = usize::from_str(iter.next().ok_or_else(|| err.clone())?)?;
        let data_iter = iter.next().unwrap();
        let data_idx = unsafe { data_iter.as_ptr().offset_from(s.as_ptr()) } as usize;
        let path = ResourcePathId::from_str(&s[data_idx..])?;
        Ok(Self {
            path,
            checksum,
            size,
        })
    }
}

/// The output of data compilation.
///
/// `Manifest` contains the list of compiled resources.
#[derive(Debug, Serialize, Deserialize, Default)]
pub struct Manifest {
    /// The description of all compiled resources.
    pub compiled_resources: Vec<CompiledResource>,
}

impl Manifest {
    /// Prepare manifest for serialization.
    /// Will sort contents to guarantee that the serialization is deterministic
    pub fn pre_serialize(&mut self) {
        self.compiled_resources.sort_by(|a, b| a.path.cmp(&b.path));
    }

    /// Creates a runtime [`lgn_data_runtime::manifest::Manifest`] from an
    /// offline [`Manifest`].
    ///
    /// Provided filter functor will be used to determine if a given asset
    /// should be included in the manifest.
    ///
    /// This is a temporary solution that will be replaced by a **packaging**
    /// process. For now, we simply create a runtime manifest by filtering
    /// out non-asset resources and by identifying content by `ResourceId` -
    /// which runtime operates on.
    pub fn into_rt_manifest(
        self,
        filter: fn(&ResourcePathId) -> bool,
    ) -> lgn_data_runtime::manifest::Manifest {
        let output = lgn_data_runtime::manifest::Manifest::default();

        let runtime_resources = self
            .compiled_resources
            .into_iter()
            .filter(|resource| filter(&resource.path))
            .collect::<Vec<_>>();

        for resource in runtime_resources {
            output.insert(
                resource.path.resource_id(),
                resource.checksum,
                resource.size,
            );
        }
        output
    }
}

/// Build target enumeration.
///
/// `TODO`: This needs to be more extensible.
#[derive(Clone, Copy)]
pub enum Target {
    /// Game client.
    Game,
    /// Server.
    Server,
    /// Backend service.
    Backend,
}

impl fmt::Display for Target {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Target::Game => write!(f, "game"),
            Target::Server => write!(f, "server"),
            Target::Backend => write!(f, "backend"),
        }
    }
}

impl FromStr for Target {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "game" => Ok(Self::Game),
            "server" => Ok(Self::Server),
            "backend" => Ok(Self::Backend),
            _ => Err(()),
        }
    }
}

/// Build platform enumeration.
#[derive(Clone, Copy)]
pub enum Platform {
    /// Windows
    Windows,
    /// Unix
    Unix,
    /// Game Console X
    ConsoleX,
}

impl fmt::Display for Platform {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Platform::Windows => write!(f, "windows"),
            Platform::Unix => write!(f, "unix"),
            Platform::ConsoleX => write!(f, "consolex"),
        }
    }
}

impl FromStr for Platform {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "windows" => Ok(Self::Windows),
            "unix" => Ok(Self::Unix),
            "consolex" => Ok(Self::ConsoleX),
            _ => Err(()),
        }
    }
}

/// Defines user's language/region.
pub struct Locale(String);

impl Locale {
    /// Creates a new Locale.
    pub fn new(v: &str) -> Self {
        Self(String::from(v))
    }
}

impl fmt::Display for Locale {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

pub mod compiler_api;
pub mod compiler_cmd;
pub mod compiler_node;
pub mod compiler_reflection;
pub mod compiler_utils;
