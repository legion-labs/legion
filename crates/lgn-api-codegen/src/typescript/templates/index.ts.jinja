// Auto-generated file

import qs from "qs";

declare global {
  interface ErrorConstructor {
    captureStackTrace(thisArg: unknown, func: unknown): void;
  }
}

export type Fetch = typeof globalThis.fetch;

export const defaultFetch = globalThis.fetch.bind(globalThis);

/**
 * All the Clients extend this class.
 */
export abstract class ApiClient {
  protected fetch: Fetch;
  protected onRequestStartInterceptors: ((
    ...request: Parameters<Fetch>
  ) => Promise<Parameters<Fetch>> | Parameters<Fetch>)[] = [];
  protected onRequestEndInterceptors: ((
    response: Response
  ) => Promise<Response> | Response)[] = [];

  constructor({ fetch = defaultFetch }: { fetch?: Fetch }) {
    this.fetch = fetch;
  }

  addRequestStartInterceptor(
    interceptor: (
      ...request: Parameters<Fetch>
    ) => Promise<Parameters<Fetch>> | Parameters<Fetch>
  ) {
    this.onRequestStartInterceptors.push(interceptor);
  }

  addRequestEndInterceptor(
    interceptor: (response: Response) => Promise<Response> | Response
  ) {
    this.onRequestEndInterceptors.push(interceptor);
  }

  protected async performRequest(
    ...args: Parameters<Fetch>
  ): Promise<Response> {
    let fetchArgs = args;

    for (const interceptor of this.onRequestStartInterceptors) {
      fetchArgs = await interceptor(...fetchArgs);
    }

    let response = await this.fetch(...fetchArgs);

    for (const interceptor of this.onRequestEndInterceptors) {
      response = await interceptor(response);
    }

    return response;
  }
}

export class InternalError extends Error {
  constructor(message: string) {
    super(`Internal error: ${message}`);

    if (Error.captureStackTrace !== undefined) {
      Error.captureStackTrace(this, InternalError);
    }

    this.name = "InternalError";
  }
}

/**
 * Automatically appends the auth header to all requests,
 * if a request is performed when the user is not authenticated,
 * the `onRefreshTokenRequired` callback is called to let you refresh the token,
 * this callback is expected to throw on error, in which case `onRefreshTokenFailure`
 * will be called.
 */
export function authedClientBuilder({
  getAccessToken,
  onRefreshTokenRequired,
  onRefreshTokenFailure,
}: {
  getAccessToken(): string | null;
  onRefreshTokenRequired(): string;
  onRefreshTokenFailure?(): void;
}) {
  return function authedClient<Client extends ApiClient>(
    client: Client,
    { minLatency = 5 }: { minLatency?: number } = {}
  ): Client {
    const state = {
      clientIsRefreshingToken: false,
    };

    client.addRequestStartInterceptor(async (input, init) => {
      if (state.clientIsRefreshingToken) {
        await new Promise<void>((resolve) => {
          const id = setInterval(() => {
            if (!state.clientIsRefreshingToken) {
              clearInterval(id);
              resolve();
            }
          }, minLatency);
        });
      }

      let accessToken = getAccessToken();

      if (accessToken === null) {
        state.clientIsRefreshingToken = true;

        try {
          accessToken = onRefreshTokenRequired();

          state.clientIsRefreshingToken = false;
        } catch {
          onRefreshTokenFailure?.();

          state.clientIsRefreshingToken = false;

          return [input, init] as [RequestInfo | URL, RequestInit | undefined];
        }
      }

      if (input instanceof Request) {
        input.headers.set("Authorization", `Bearer ${accessToken}`);
      }

      if (init?.headers instanceof Headers) {
        init.headers.set("Authorization", `Bearer ${accessToken}`);
      }

      return [input, init] as [RequestInfo | URL, RequestInit | undefined];
    });

    return client;
  };
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function stringifyQueryObject(obj: any): string {
  return qs.stringify(obj, { arrayFormat: "repeat" });
}
