from enum import Enum
from json import JSONEncoder

#used by fmt_type
from datetime import datetime, date
from typing import Any

# TODO(kdaibov): starting with Python 3.11 we could use StrEnum
# in that case we could remove the ModelEncoder
class ModelEncoder(JSONEncoder):
    def default(self, o):
        if isinstance(o, Enum):
            return o.value
        else:
            return o.__dict__

{% for model in location_ctx.models.values() %}
{% if let Some(description) = model.description %}# {{ description }}{% endif %}
{%- let model_name = model|fmt_model_name(ctx) %}
{%- match model.type_ %}
{%- when Type::Enum with { variants } %}
class {{ model_name }}(Enum):
{%- for variant in variants %}
    {{ variant|upper }} = "{{ variant }}"
{%- endfor %}
    def from_json(value):
        return {{ model_name }}(value)

{%- when Type::OneOf with { types } %}
class {{ model_name }}:
    def __init__(self, value):
        self.value = value 
        self.type = None
        {% for type_ in types %}
        if isinstance(value, {{type_|fmt_type(ctx)}}):
            self.type = {{ type_|fmt_type(ctx) }}
        {% endfor %}

    def from_json(body):
        value = None
        {% for type_ in types %}
        if "option{{ loop.index }}" in body:
            value = {{ type_|fmt_type(ctx) }}.from_json(body["option{{ loop.index }}"])
        {% endfor %}
        return {{ model_name }}(
            value
        )

    def __str__(self):
        return "{{ model_name }} ( value: {} )".format(self.value)

                
{% when Type::Struct with { fields, map } %}
class {{ model_name }}:
    def __init__(
        self,
        {%- for field in fields.values() %}
        {{ field.name }}, # : {{ field.type_|fmt_type(ctx) }} {% if let Some(description) = field.description -%} # {{ description }}{%- endif %}
        {%- endfor %}
        {% match map %}
        {% when Some with (map) %}
        additional_properties: dict[str, {{ map|fmt_type(ctx) }}]
        {% when None %}
        {% endmatch %}
    ):
    {%- for field in fields.values() %}
        self.{{ field.name }} = {{ field.name }}
    {%- endfor %}
    {% if map.is_some() %}
        self.additional_properties = additional_properties
    {% endif %}

    def to_json(self):
        return ModelEncoder().encode(self)

    def from_json(body):
        {%- for field in fields.values() %}
        {%- match field.type_ %}
        {%- when Type::Named with ( type_name ) %}
        {{field.name}} = {{ field.type_|fmt_type(ctx) }}.from_json(body['{{field.name}}'])
        {%- when Type::Array with (inner_type)%}
        {%- match inner_type.deref() %}
        {%- when Type::Named with (array_type_name)%}
        {{field.name}} = []
        for item in body['{{field.name}}']:
            {{field.name}}.append({{ inner_type.deref()|fmt_type(ctx) }}.from_json(item))
        {%- else %}
        {{field.name}} = body['{{field.name}}']
        {%- endmatch %}
        {%- else %}
        {{field.name}} = body['{{field.name}}']
        {%- endmatch %}
        {%- endfor %}
        return {{ model_name }}(
            {%- for field in fields.values() %}
            {{ field.name }},
            {%- endfor %}
        )

    def __str__(self):
        return ("{{ model_name }} (\n"
        {%- for field in fields.values() %}
        "  {{field.name}} : {}\n"
        {%- endfor %}
        ")"
        ).format(
        {%- for field in fields.values() %}
            self.{{ field.name }},
        {%- endfor %}
        )

{%- when t %}
class {{ model_name }}:
    def __init__(
        self,
        value: {{ t|fmt_type(ctx) }}
    ):
        self.value = value

    def to_json(self):
        return ModelEncoder().encode(self)

    def from_json(body):
        return {{ model_name }}(body)

    def __str__(self):
        return "{{ model_name }} ( value: {} )".format(self.value)

{% endmatch %}
{% endfor %}