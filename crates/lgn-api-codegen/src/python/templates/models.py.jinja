from enum import Enum

from json import JSONEncoder

# TODO(kdaibov): starting with Python 3.11 we could use StrEnum
# in that case we could remove the ModelEncoder
class ModelEncoder(JSONEncoder):
    def default(self, o):
        if isinstance(o, Enum):
            return o.value
        else:
            return o.__dict__

{% for model in api.models %}
{%- match model %}
{% when Model::Enum with (enum_) %}
{% if let Some(description) = enum_.description %}# {{ description }}{% endif %}
class {{ enum_.name }}(Enum):
{%- for variant in enum_.variants %}
    {{ variant|upper }} = "{{ variant }}"
{%- endfor %}

# TODO(kdaibov): OneOf is not tested
{% when Model::OneOf with (one_of) %}
{% if let Some(description) = one_of.description %}# {{ description }}{% endif %}
class {{ one_of.name }}:
    def __init__(self, value):
        self.value = value 
        self.type = None
    {% for type_ in one_of.types %}
        if isinstance(value, {{type_|fmt_type}}):
            self.type = "{{ type_|fmt_type }}"
    {% endfor %}
                
{% when Model::Struct with (struct_) %}
{% if let Some(description) = struct_.description %}# {{ description }}{% endif %}
class {{ struct_.name }}:
    def __init__(
        self,
        {%- for field in struct_.fields %}
        {{ field.name }} : {{ field.type_|fmt_type }}, {% if let Some(description) = field.description -%} # {{ description }}{%- endif %}
        {%- endfor %}
    ):
    {%- for field in struct_.fields %}
        self.{{ field.name }} = {{ field.name }}
    {%- endfor %}

    def to_json(self):
        return ModelEncoder().encode(self)
   
{% endmatch %}
{% endfor %}