---
source: crates/lgn-api-codegen/src/rust/mod.rs
expression: content
---
// Auto-generated file for Api: Test API : 1.0.0
//
// This is a sample OpenAPI 3.0 specification.
//

// ---------- Api ----------
use errors::Result;
use lgn_online::codegen::Context;

#[async_trait::async_trait]
pub trait Api {
    async fn test_one_of(&self, context: &mut Context) -> Result<responses::TestOneOfResponse>;

    async fn get_cars(
        &self,
        context: &mut Context,
        request: requests::GetCarsRequest,
    ) -> Result<responses::GetCarsResponse>;

    async fn create_car(
        &self,
        context: &mut Context,
        request: requests::CreateCarRequest,
    ) -> Result<responses::CreateCarResponse>;

    async fn get_car(
        &self,
        context: &mut Context,
        request: requests::GetCarRequest,
    ) -> Result<responses::GetCarResponse>;

    async fn delete_car(
        &self,
        context: &mut Context,
        request: requests::DeleteCarRequest,
    ) -> Result<responses::DeleteCarResponse>;

    async fn test_binary(
        &self,
        context: &mut Context,
        request: requests::TestBinaryRequest,
    ) -> Result<responses::TestBinaryResponse>;
}

// ---------- Errors ----------
pub mod errors {
    use axum::{
        http::StatusCode,
        response::{IntoResponse, Response},
    };
    use lgn_tracing::warn;

    #[derive(thiserror::Error, Debug)]
    pub enum Error {
        #[error("internal: {0}")]
        Internal(String),
        #[error("hyper: {0}")]
        Hyper(#[from] hyper::Error),
        #[error("serde json: {0}")]
        SerdeJson(#[from] serde_json::Error),
        #[error("serde qs: {0}")]
        SerdeQs(#[from] serde_qs::Error),
        #[error("codegen encoding: {0}")]
        CodegenEncoding(#[from] lgn_online::codegen::encoding::Error),
        #[error("invalid body: {0}")]
        InvalidBody(String),
        #[error("invalid header: {0}")]
        InvalidHeader(String),
        #[error("missing header: {0}")]
        MissingHeader(String),
    }

    pub type Result<T, E = Error> = std::result::Result<T, E>;

    impl IntoResponse for Error {
        fn into_response(self) -> Response {
            warn!("converted error into HTTP response: {}", self);

            match self {
                Self::Internal(_) | Self::Hyper(_) | Self::SerdeJson(_) | Self::SerdeQs(_) => {
                    StatusCode::INTERNAL_SERVER_ERROR.into_response()
                }
                Self::CodegenEncoding(_)
                | Self::InvalidBody(_)
                | Self::InvalidHeader(_)
                | Self::MissingHeader(_) => StatusCode::BAD_REQUEST.into_response(),
            }
        }
    }

    pub trait ErrorExt<T> {
        /// Converts to an internal server error.
        /// # Errors
        /// If we fail to return a response.
        fn into_internal_server_error(self) -> Result<T, Error>;
    }

    impl<T, E: std::error::Error> ErrorExt<T> for Result<T, E> {
        fn into_internal_server_error(self) -> Result<T, Error> {
            self.map_err(|err| Error::Internal(err.to_string()))
        }
    }
}

// ---------- Client ----------
pub mod client {
    use super::{
        errors::{Error, Result},
        params, requests, responses,
    };
    use http::{header::CONTENT_TYPE, HeaderValue};
    use hyper::{Body, Method, Request};
    use lgn_online::codegen::{Bytes, Context};

    pub struct Client<C> {
        inner: hyper::Client<C>,
        base_uri: String,
    }

    impl<C> Client<C> {
        pub fn new(inner: hyper::Client<C>, base_uri: String) -> Self {
            Self { inner, base_uri }
        }
    }

    #[async_trait::async_trait]
    impl<C> super::Api for Client<C>
    where
        C: hyper::client::connect::Connect + Clone + Send + Sync + 'static,
    {
        async fn test_one_of(&self, context: &mut Context) -> Result<responses::TestOneOfResponse> {
            let mut uri = format!("{}/test-one-of", self.base_uri);

            let mut req = Request::builder()
                .method(Method::GET)
                .uri(uri)
                .body(Body::empty())
                .unwrap();
            if let Some(extensions) = context.request_extensions() {
                req.extensions_mut().extend(extensions);
            }

            if let Some(headers) = context.request_headers() {
                req.headers_mut().extend(headers);
            }

            let resp = self.inner.request(req).await?;

            let (parts, body) = resp.into_parts();
            let status = parts.status;
            context.set_response(parts);

            responses::TestOneOfResponse::from_response(status, body).await
        }

        async fn get_cars(
            &self,
            context: &mut Context,
            request: requests::GetCarsRequest,
        ) -> Result<responses::GetCarsResponse> {
            let mut uri = format!(
                "{}/v1/spaces/{}/car-service/cars",
                self.base_uri,
                lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?
            );

            let query = params::GetCarsQuery {
                names: request.names,
                q: request.q,
            };
            let query_string = serde_qs::to_string(&query)?;
            if !query_string.is_empty() {
                uri += &format!("?{}", query_string);
            }
            let mut req = Request::builder()
                .method(Method::GET)
                .uri(uri)
                .body(Body::empty())
                .unwrap();
            if let Some(extensions) = context.request_extensions() {
                req.extensions_mut().extend(extensions);
            }

            if let Some(headers) = context.request_headers() {
                req.headers_mut().extend(headers);
            }

            let resp = self.inner.request(req).await?;

            let (parts, body) = resp.into_parts();
            let status = parts.status;
            context.set_response(parts);

            responses::GetCarsResponse::from_response(status, body).await
        }

        async fn create_car(
            &self,
            context: &mut Context,
            request: requests::CreateCarRequest,
        ) -> Result<responses::CreateCarResponse> {
            let mut uri = format!(
                "{}/v1/spaces/{}/car-service/cars",
                self.base_uri,
                lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?
            );

            let mut req = Request::builder()
                .method(Method::POST)
                .uri(uri)
                .body(Body::from(serde_json::to_string(&request.body)?))
                .map_err(|err| Error::InvalidBody(err.to_string()))?;

            if let Some(extensions) = context.request_extensions() {
                req.extensions_mut().extend(extensions);
            }

            if let Some(headers) = context.request_headers() {
                req.headers_mut().extend(headers);
            }

            req.headers_mut()
                .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));

            if let Some(span_id) = request.span_id {
                req.headers_mut().insert(
                    "span-id",
                    HeaderValue::from_str(&span_id)
                        .map_err(|err| Error::InvalidHeader(format!("span-id: {}", err)))?,
                );
            }
            let resp = self.inner.request(req).await?;

            let (parts, body) = resp.into_parts();
            let status = parts.status;
            context.set_response(parts);

            responses::CreateCarResponse::from_response(status, body).await
        }

        async fn get_car(
            &self,
            context: &mut Context,
            request: requests::GetCarRequest,
        ) -> Result<responses::GetCarResponse> {
            let mut uri = format!(
                "{}/v1/spaces/{}/car-service/cars/{}",
                self.base_uri,
                lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?,
                lgn_online::codegen::encoding::to_percent_encoded_string(&request.car_id)?
            );

            let mut req = Request::builder()
                .method(Method::GET)
                .uri(uri)
                .body(Body::empty())
                .unwrap();
            if let Some(extensions) = context.request_extensions() {
                req.extensions_mut().extend(extensions);
            }

            if let Some(headers) = context.request_headers() {
                req.headers_mut().extend(headers);
            }

            let resp = self.inner.request(req).await?;

            let (parts, body) = resp.into_parts();
            let status = parts.status;
            context.set_response(parts);

            responses::GetCarResponse::from_response(status, body).await
        }

        async fn delete_car(
            &self,
            context: &mut Context,
            request: requests::DeleteCarRequest,
        ) -> Result<responses::DeleteCarResponse> {
            let mut uri = format!(
                "{}/v1/spaces/{}/car-service/cars/{}",
                self.base_uri,
                lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?,
                lgn_online::codegen::encoding::to_percent_encoded_string(&request.car_id)?
            );

            let mut req = Request::builder()
                .method(Method::DELETE)
                .uri(uri)
                .body(Body::empty())
                .unwrap();
            if let Some(extensions) = context.request_extensions() {
                req.extensions_mut().extend(extensions);
            }

            if let Some(headers) = context.request_headers() {
                req.headers_mut().extend(headers);
            }

            let resp = self.inner.request(req).await?;

            let (parts, body) = resp.into_parts();
            let status = parts.status;
            context.set_response(parts);

            responses::DeleteCarResponse::from_response(status, body).await
        }

        async fn test_binary(
            &self,
            context: &mut Context,
            request: requests::TestBinaryRequest,
        ) -> Result<responses::TestBinaryResponse> {
            let mut uri = format!(
                "{}/v1/spaces/{}/car-service/test-binary",
                self.base_uri,
                lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?
            );

            let mut req = Request::builder()
                .method(Method::POST)
                .uri(uri)
                .body(Body::from(request.body))
                .map_err(|err| Error::InvalidBody(err.to_string()))?;

            if let Some(extensions) = context.request_extensions() {
                req.extensions_mut().extend(extensions);
            }

            if let Some(headers) = context.request_headers() {
                req.headers_mut().extend(headers);
            }

            req.headers_mut().insert(
                CONTENT_TYPE,
                HeaderValue::from_static("application/octet-stream"),
            );
            let resp = self.inner.request(req).await?;

            let (parts, body) = resp.into_parts();
            let status = parts.status;
            context.set_response(parts);

            responses::TestBinaryResponse::from_response(status, body).await
        }
    }
}

// ---------- Server ----------
pub mod server {
    use super::errors::{Error, Result};
    use super::params;
    use super::requests;
    use axum::{
        extract::ConnectInfo,
        extract::Json,
        extract::Path,
        http::Request,
        response::{IntoResponse, Response},
        routing, Extension, Router,
    };
    use http::header::HeaderName;
    use http::request::Parts;
    use lgn_online::codegen::{Bytes, Context};
    use lgn_tracing::error;
    use serde_qs::axum::QsQuery;
    use std::net::SocketAddr;

    /// Register all the routes for that API to the specified Router.
    #[must_use]
    pub fn register_routes<T>(router: Router, api: T) -> Router
    where
        T: super::Api + Clone + Send + Sync + 'static,
    {
        router
            .route("/test-one-of", routing::get(test_one_of::<T>))
            .route(
                "/v1/spaces/:space-id/car-service/cars",
                routing::get(get_cars::<T>).post(create_car::<T>),
            )
            .route(
                "/v1/spaces/:space-id/car-service/cars/:car-id",
                routing::get(get_car::<T>).delete(delete_car::<T>),
            )
            .route(
                "/v1/spaces/:space-id/car-service/test-binary",
                routing::post(test_binary::<T>),
            )
            .layer(Extension(api))
    }

    async fn test_one_of<T>(
        Extension(api): Extension<T>,
        ConnectInfo(addr): ConnectInfo<SocketAddr>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::default();
        context.set_request_addr(addr);
        context.set_request(parts);

        let resp = api.test_one_of(&mut context).await;
        let mut resp = match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        };

        if let Some(extensions) = context.response_extensions() {
            resp.extensions_mut().extend(extensions);
        }

        if let Some(headers) = context.response_headers() {
            resp.headers_mut().extend(headers);
        }

        resp
    }

    async fn get_cars<T>(
        Extension(api): Extension<T>,
        Path(space_id): Path<String>,
        QsQuery(query): QsQuery<params::GetCarsQuery>,
        ConnectInfo(addr): ConnectInfo<SocketAddr>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::default();
        context.set_request_addr(addr);
        context.set_request(parts);

        let request = requests::GetCarsRequest {
            space_id,
            names: query.names,
            q: query.q,
        };

        let resp = api.get_cars(&mut context, request).await;
        let mut resp = match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        };

        if let Some(extensions) = context.response_extensions() {
            resp.extensions_mut().extend(extensions);
        }

        if let Some(headers) = context.response_headers() {
            resp.headers_mut().extend(headers);
        }

        resp
    }

    async fn create_car<T>(
        Extension(api): Extension<T>,
        Path(space_id): Path<String>,
        Json(body): Json<super::models::Car>,
        ConnectInfo(addr): ConnectInfo<SocketAddr>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let span_id = parts.headers.get(HeaderName::from_static("span-id"));
        let span_id = span_id.map(|span_id| {
            span_id
                .to_str()
                .map_err(|err| {
                    error!("Failed to read `span-id` header: {}", err);
                    Error::InvalidHeader("span-id".to_owned()).into_response()
                })
                .unwrap()
                .to_owned()
        });

        let mut context = Context::default();
        context.set_request_addr(addr);
        context.set_request(parts);

        let request = requests::CreateCarRequest {
            space_id,
            span_id,
            body,
        };

        let resp = api.create_car(&mut context, request).await;
        let mut resp = match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        };

        if let Some(extensions) = context.response_extensions() {
            resp.extensions_mut().extend(extensions);
        }

        if let Some(headers) = context.response_headers() {
            resp.headers_mut().extend(headers);
        }

        resp
    }

    async fn get_car<T>(
        Extension(api): Extension<T>,
        Path((space_id, car_id)): Path<(String, i64)>,
        ConnectInfo(addr): ConnectInfo<SocketAddr>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::default();
        context.set_request_addr(addr);
        context.set_request(parts);

        let request = requests::GetCarRequest { space_id, car_id };

        let resp = api.get_car(&mut context, request).await;
        let mut resp = match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        };

        if let Some(extensions) = context.response_extensions() {
            resp.extensions_mut().extend(extensions);
        }

        if let Some(headers) = context.response_headers() {
            resp.headers_mut().extend(headers);
        }

        resp
    }

    async fn delete_car<T>(
        Extension(api): Extension<T>,
        Path((space_id, car_id)): Path<(String, i64)>,
        ConnectInfo(addr): ConnectInfo<SocketAddr>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::default();
        context.set_request_addr(addr);
        context.set_request(parts);

        let request = requests::DeleteCarRequest { space_id, car_id };

        let resp = api.delete_car(&mut context, request).await;
        let mut resp = match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        };

        if let Some(extensions) = context.response_extensions() {
            resp.extensions_mut().extend(extensions);
        }

        if let Some(headers) = context.response_headers() {
            resp.headers_mut().extend(headers);
        }

        resp
    }

    async fn test_binary<T>(
        Extension(api): Extension<T>,
        Path(space_id): Path<String>,
        body: axum::body::Bytes,
        ConnectInfo(addr): ConnectInfo<SocketAddr>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::default();
        context.set_request_addr(addr);
        context.set_request(parts);

        let request = requests::TestBinaryRequest {
            space_id,
            body: body.into(),
        };

        let resp = api.test_binary(&mut context, request).await;
        let mut resp = match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        };

        if let Some(extensions) = context.response_extensions() {
            resp.extensions_mut().extend(extensions);
        }

        if let Some(headers) = context.response_headers() {
            resp.headers_mut().extend(headers);
        }

        resp
    }
}

// ---------- Models ----------
pub mod models {
    use lgn_online::codegen::Bytes;

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Car {
        #[serde(rename = "color")]
        pub color: super::models::CarColor,

        #[serde(rename = "extra")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub extra: Option<Bytes>,

        #[serde(rename = "id")]
        pub id: i64,

        #[serde(rename = "is_new")]
        pub is_new: bool,

        #[serde(rename = "name")]
        pub name: String,
    }

    /// The car color.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub enum CarColor {
        #[serde(rename = "red")]
        Red,
        #[serde(rename = "blue")]
        Blue,
        #[serde(rename = "yellow")]
        Yellow,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Cars(pub Vec<super::models::Car>);

    impl From<Vec<super::models::Car>> for Cars {
        fn from(t: Vec<super::models::Car>) -> Self {
            Self(t)
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Pet {
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub enum TestOneOfResponse {
        #[serde(rename = "option1")]
        Option1(super::models::Pet),
        #[serde(rename = "option2")]
        Option2(super::models::Car),
    }
}

// ---------- Params ----------
pub(crate) mod params {
    // Types used server side by axum to parse the request body.

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct GetCarsQuery {
        #[serde(rename = "names")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub names: Option<Vec<String>>,
        #[serde(rename = "q")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub q: Option<String>,
    }
}

// ---------- Requests ----------
pub mod requests {
    use lgn_online::codegen::Bytes;

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct GetCarsRequest {
        pub space_id: String,
        pub names: Option<Vec<String>>,
        pub q: Option<String>,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct CreateCarRequest {
        pub space_id: String,
        pub span_id: Option<String>,
        pub body: super::models::Car,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct GetCarRequest {
        pub space_id: String,
        pub car_id: i64,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct DeleteCarRequest {
        pub space_id: String,
        pub car_id: i64,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct TestBinaryRequest {
        pub space_id: String,
        pub body: Bytes,
    }
}

// ---------- Responses ----------
pub mod responses {
    use super::errors::{Error, Result};
    use axum::{
        http::StatusCode,
        response::{IntoResponse, Response},
        Json,
    };
    use lgn_online::codegen::Bytes;

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum TestOneOfResponse {
        /// Ok.
        Status200(super::models::TestOneOfResponse),
    }

    impl TestOneOfResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                TestOneOfResponse::Status200(body) => {
                    let body = Json(body);
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let body = serde_json::from_slice(&bytes)?;

                    Ok(Self::Status200(body))
                }
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum GetCarsResponse {
        /// List of cars.
        Status200(super::models::Cars),
    }

    impl GetCarsResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                GetCarsResponse::Status200(body) => {
                    let body = Json(body);
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let body = serde_json::from_slice(&bytes)?;

                    Ok(Self::Status200(body))
                }
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum CreateCarResponse {
        /// Created.
        Status201,
    }

    impl CreateCarResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                CreateCarResponse::Status201 => StatusCode::from_u16(201).unwrap().into_response(),
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                201 => Ok(Self::Status201),
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum GetCarResponse {
        /// A car.
        Status200(super::models::Car),
        /// Car not found.
        Status404,
    }

    impl GetCarResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                GetCarResponse::Status200(body) => {
                    let body = Json(body);
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
                GetCarResponse::Status404 => StatusCode::from_u16(404).unwrap().into_response(),
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let body = serde_json::from_slice(&bytes)?;

                    Ok(Self::Status200(body))
                }

                404 => Ok(Self::Status404),
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum DeleteCarResponse {
        /// Car deleted.
        Status200,
        /// Car not found.
        Status404,
    }

    impl DeleteCarResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                DeleteCarResponse::Status200 => StatusCode::from_u16(200).unwrap().into_response(),
                DeleteCarResponse::Status404 => StatusCode::from_u16(404).unwrap().into_response(),
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => Ok(Self::Status200),

                404 => Ok(Self::Status404),
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum TestBinaryResponse {
        /// Ok.
        Status200(Bytes),
    }

    impl TestBinaryResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                TestBinaryResponse::Status200(body) => {
                    let body: Vec<u8> = body.into();
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let body = bytes.into();

                    Ok(Self::Status200(body))
                }
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }
}

