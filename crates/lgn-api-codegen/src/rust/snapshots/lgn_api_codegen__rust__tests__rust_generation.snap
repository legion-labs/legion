---
source: crates/lgn-api-codegen/src/rust/mod.rs
expression: content
---
// Auto-generated file.

// Models and API from: cars

pub mod cars {

    use lgn_online::{codegen::Bytes, server::Error};

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub enum TestOneOf200Response {
        #[serde(rename = "option1")]
        Option1(super::components::Pet),
        #[serde(rename = "option2")]
        Option2(super::components::Car),
    }

    // API Test API v1.0.0
    //
    // This is a sample OpenAPI 3.0 specification.
    //

    // ---------- Api ----------
    use lgn_online::server::Result;

    #[async_trait::async_trait]
    pub trait Api {
        async fn test_headers(
            &self,
            parts: http::request::Parts,
            request: requests::TestHeadersRequest,
        ) -> Result<responses::TestHeadersResponse>;

        async fn test_one_of(
            &self,
            parts: http::request::Parts,
        ) -> Result<responses::TestOneOfResponse>;

        async fn get_cars(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarsRequest,
        ) -> Result<responses::GetCarsResponse>;

        async fn create_car(
            &self,
            parts: http::request::Parts,
            request: requests::CreateCarRequest,
        ) -> Result<responses::CreateCarResponse>;

        async fn get_car(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarRequest,
        ) -> Result<responses::GetCarResponse>;

        async fn delete_car(
            &self,
            parts: http::request::Parts,
            request: requests::DeleteCarRequest,
        ) -> Result<responses::DeleteCarResponse>;

        async fn test_binary(
            &self,
            parts: http::request::Parts,
            request: requests::TestBinaryRequest,
        ) -> Result<responses::TestBinaryResponse>;
    }

    // Blanket implementation of the Api trait for common wrapper types.

    #[async_trait::async_trait]
    impl<T: Api + Send + Sync> Api for std::sync::Arc<T> {
        async fn test_headers(
            &self,
            parts: http::request::Parts,
            request: requests::TestHeadersRequest,
        ) -> Result<responses::TestHeadersResponse> {
            self.as_ref().test_headers(parts, request).await
        }

        async fn test_one_of(
            &self,
            parts: http::request::Parts,
        ) -> Result<responses::TestOneOfResponse> {
            self.as_ref().test_one_of(parts).await
        }

        async fn get_cars(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarsRequest,
        ) -> Result<responses::GetCarsResponse> {
            self.as_ref().get_cars(parts, request).await
        }

        async fn create_car(
            &self,
            parts: http::request::Parts,
            request: requests::CreateCarRequest,
        ) -> Result<responses::CreateCarResponse> {
            self.as_ref().create_car(parts, request).await
        }

        async fn get_car(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarRequest,
        ) -> Result<responses::GetCarResponse> {
            self.as_ref().get_car(parts, request).await
        }

        async fn delete_car(
            &self,
            parts: http::request::Parts,
            request: requests::DeleteCarRequest,
        ) -> Result<responses::DeleteCarResponse> {
            self.as_ref().delete_car(parts, request).await
        }

        async fn test_binary(
            &self,
            parts: http::request::Parts,
            request: requests::TestBinaryRequest,
        ) -> Result<responses::TestBinaryResponse> {
            self.as_ref().test_binary(parts, request).await
        }
    }

    #[async_trait::async_trait]
    impl<T: Api + Send + Sync + ?Sized> Api for Box<T> {
        async fn test_headers(
            &self,
            parts: http::request::Parts,
            request: requests::TestHeadersRequest,
        ) -> Result<responses::TestHeadersResponse> {
            self.as_ref().test_headers(parts, request).await
        }

        async fn test_one_of(
            &self,
            parts: http::request::Parts,
        ) -> Result<responses::TestOneOfResponse> {
            self.as_ref().test_one_of(parts).await
        }

        async fn get_cars(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarsRequest,
        ) -> Result<responses::GetCarsResponse> {
            self.as_ref().get_cars(parts, request).await
        }

        async fn create_car(
            &self,
            parts: http::request::Parts,
            request: requests::CreateCarRequest,
        ) -> Result<responses::CreateCarResponse> {
            self.as_ref().create_car(parts, request).await
        }

        async fn get_car(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarRequest,
        ) -> Result<responses::GetCarResponse> {
            self.as_ref().get_car(parts, request).await
        }

        async fn delete_car(
            &self,
            parts: http::request::Parts,
            request: requests::DeleteCarRequest,
        ) -> Result<responses::DeleteCarResponse> {
            self.as_ref().delete_car(parts, request).await
        }

        async fn test_binary(
            &self,
            parts: http::request::Parts,
            request: requests::TestBinaryRequest,
        ) -> Result<responses::TestBinaryResponse> {
            self.as_ref().test_binary(parts, request).await
        }
    }

    #[async_trait::async_trait]
    impl<T: Api + Send + Sync + ?Sized> Api for &T {
        async fn test_headers(
            &self,
            parts: http::request::Parts,
            request: requests::TestHeadersRequest,
        ) -> Result<responses::TestHeadersResponse> {
            (**self).test_headers(parts, request).await
        }

        async fn test_one_of(
            &self,
            parts: http::request::Parts,
        ) -> Result<responses::TestOneOfResponse> {
            (**self).test_one_of(parts).await
        }

        async fn get_cars(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarsRequest,
        ) -> Result<responses::GetCarsResponse> {
            (**self).get_cars(parts, request).await
        }

        async fn create_car(
            &self,
            parts: http::request::Parts,
            request: requests::CreateCarRequest,
        ) -> Result<responses::CreateCarResponse> {
            (**self).create_car(parts, request).await
        }

        async fn get_car(
            &self,
            parts: http::request::Parts,
            request: requests::GetCarRequest,
        ) -> Result<responses::GetCarResponse> {
            (**self).get_car(parts, request).await
        }

        async fn delete_car(
            &self,
            parts: http::request::Parts,
            request: requests::DeleteCarRequest,
        ) -> Result<responses::DeleteCarResponse> {
            (**self).delete_car(parts, request).await
        }

        async fn test_binary(
            &self,
            parts: http::request::Parts,
            request: requests::TestBinaryRequest,
        ) -> Result<responses::TestBinaryResponse> {
            (**self).test_binary(parts, request).await
        }
    }

    // ---------- Client ----------
    pub mod client {

        use super::{params, requests, responses};
        use http::{header::CONTENT_TYPE, HeaderValue, Request, Response};
        use hyper::service::Service;
        use lgn_online::{
            codegen::Bytes,
            server::{Error, Result},
        };
        use lgn_tracing::debug;

        #[derive(Debug)]
        pub struct Client<C> {
            inner: C,
            base_uri: http::Uri,
        }

        impl<C> Client<C> {
            pub fn new(inner: C, base_uri: http::Uri) -> Self {
                Self { inner, base_uri }
            }
        }

        impl<C, ResBody> Client<C>
        where
            C: Service<Request<hyper::Body>, Response = Response<ResBody>> + Clone + Send + Sync,
            C::Error: Into<lgn_online::server::StdError>,
            C::Future: Send,
            ResBody: hyper::body::HttpBody + Send,
            ResBody::Data: Send,
            ResBody::Error: Into<lgn_online::server::StdError>,
        {
            /// Call to `test_headers`.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn test_headers(
                &self,
                request: requests::TestHeadersRequest,
            ) -> Result<responses::TestHeadersResponse> {
                self.test_headers_with_parts(request)
                    .await
                    .map(|(_, resp)| resp)
            }

            /// Call to `test_headers` including response parts.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn test_headers_with_parts(
                &self,
                request: requests::TestHeadersRequest,
            ) -> Result<(http::response::Parts, responses::TestHeadersResponse)> {
                let mut uri = format!(
                    "{}://{}/test-headers",
                    self.base_uri.scheme_str().unwrap(),
                    self.base_uri.authority().unwrap()
                );

                debug!("test_headers: {}", uri);

                let body = hyper::Body::empty();
                let mut req = Request::builder()
                    .method(hyper::Method::GET)
                    .uri(uri)
                    .body(body)?;

                if let Some(x_string_header) = request.x_string_header {
                    let x_string_header =
                        lgn_online::codegen::encoding::to_percent_encoded_string(&x_string_header)?;
                    req.headers_mut().insert(
                        "x-string-header",
                        HeaderValue::from_str(&x_string_header).map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-string-header: {}", err))
                        })?,
                    );
                }

                if let Some(x_bytes_header) = request.x_bytes_header {
                    let x_bytes_header =
                        lgn_online::codegen::encoding::to_percent_encoded_string(&x_bytes_header)?;
                    req.headers_mut().insert(
                        "x-bytes-header",
                        HeaderValue::from_str(&x_bytes_header).map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-bytes-header: {}", err))
                        })?,
                    );
                }

                if let Some(x_int_header) = request.x_int_header {
                    let x_int_header =
                        lgn_online::codegen::encoding::to_percent_encoded_string(&x_int_header)?;
                    req.headers_mut().insert(
                        "x-int-header",
                        HeaderValue::from_str(&x_int_header).map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-int-header: {}", err))
                        })?,
                    );
                }
                let mut client = self.inner.clone();
                let resp = client.call(req).await.map_err(Into::into)?;

                responses::TestHeadersResponse::from_response(resp).await
            }

            /// Call to `test_one_of`.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn test_one_of(&self) -> Result<responses::TestOneOfResponse> {
                self.test_one_of_with_parts().await.map(|(_, resp)| resp)
            }

            /// Call to `test_one_of` including response parts.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn test_one_of_with_parts(
                &self,
            ) -> Result<(http::response::Parts, responses::TestOneOfResponse)> {
                let mut uri = format!(
                    "{}://{}/test-one-of",
                    self.base_uri.scheme_str().unwrap(),
                    self.base_uri.authority().unwrap()
                );

                debug!("test_one_of: {}", uri);

                let body = hyper::Body::empty();
                let mut req = Request::builder()
                    .method(hyper::Method::GET)
                    .uri(uri)
                    .body(body)?;

                let mut client = self.inner.clone();
                let resp = client.call(req).await.map_err(Into::into)?;

                responses::TestOneOfResponse::from_response(resp).await
            }

            /// Call to `get_cars`.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn get_cars(
                &self,
                request: requests::GetCarsRequest,
            ) -> Result<responses::GetCarsResponse> {
                self.get_cars_with_parts(request)
                    .await
                    .map(|(_, resp)| resp)
            }

            /// Call to `get_cars` including response parts.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn get_cars_with_parts(
                &self,
                request: requests::GetCarsRequest,
            ) -> Result<(http::response::Parts, responses::GetCarsResponse)> {
                let mut uri = format!(
                    "{}://{}/v1/spaces/{}/car-service/cars",
                    self.base_uri.scheme_str().unwrap(),
                    self.base_uri.authority().unwrap(),
                    lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?
                );

                let query = params::GetCarsQuery {
                    names: request.names,
                    q: request.q,
                };
                let query_string = serde_qs::to_string(&query)?;
                if !query_string.is_empty() {
                    uri += &format!("?{}", query_string);
                }
                debug!("get_cars: {}", uri);

                let body = hyper::Body::empty();
                let mut req = Request::builder()
                    .method(hyper::Method::GET)
                    .uri(uri)
                    .body(body)?;

                let mut client = self.inner.clone();
                let resp = client.call(req).await.map_err(Into::into)?;

                responses::GetCarsResponse::from_response(resp).await
            }

            /// Call to `create_car`.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn create_car(
                &self,
                request: requests::CreateCarRequest,
            ) -> Result<responses::CreateCarResponse> {
                self.create_car_with_parts(request)
                    .await
                    .map(|(_, resp)| resp)
            }

            /// Call to `create_car` including response parts.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn create_car_with_parts(
                &self,
                request: requests::CreateCarRequest,
            ) -> Result<(http::response::Parts, responses::CreateCarResponse)> {
                let mut uri = format!(
                    "{}://{}/v1/spaces/{}/car-service/cars",
                    self.base_uri.scheme_str().unwrap(),
                    self.base_uri.authority().unwrap(),
                    lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?
                );

                debug!("create_car: {}", uri);

                let body = hyper::Body::from(serde_json::to_string(&request.body)?);

                let mut req = Request::builder()
                    .method(hyper::Method::POST)
                    .uri(uri)
                    .body(body)?;

                req.headers_mut()
                    .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));

                if let Some(span_id) = request.span_id {
                    let span_id =
                        lgn_online::codegen::encoding::to_percent_encoded_string(&span_id)?;
                    req.headers_mut().insert(
                        "span-id",
                        HeaderValue::from_str(&span_id).map_err(|err| {
                            Error::BadRequest(format!("invalid header: span-id: {}", err))
                        })?,
                    );
                }
                let mut client = self.inner.clone();
                let resp = client.call(req).await.map_err(Into::into)?;

                responses::CreateCarResponse::from_response(resp).await
            }

            /// Call to `get_car`.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn get_car(
                &self,
                request: requests::GetCarRequest,
            ) -> Result<responses::GetCarResponse> {
                self.get_car_with_parts(request).await.map(|(_, resp)| resp)
            }

            /// Call to `get_car` including response parts.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn get_car_with_parts(
                &self,
                request: requests::GetCarRequest,
            ) -> Result<(http::response::Parts, responses::GetCarResponse)> {
                let mut uri = format!(
                    "{}://{}/v1/spaces/{}/car-service/cars/{}",
                    self.base_uri.scheme_str().unwrap(),
                    self.base_uri.authority().unwrap(),
                    lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?,
                    lgn_online::codegen::encoding::to_percent_encoded_string(&request.car_id)?
                );

                debug!("get_car: {}", uri);

                let body = hyper::Body::empty();
                let mut req = Request::builder()
                    .method(hyper::Method::GET)
                    .uri(uri)
                    .body(body)?;

                let mut client = self.inner.clone();
                let resp = client.call(req).await.map_err(Into::into)?;

                responses::GetCarResponse::from_response(resp).await
            }

            /// Call to `delete_car`.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn delete_car(
                &self,
                request: requests::DeleteCarRequest,
            ) -> Result<responses::DeleteCarResponse> {
                self.delete_car_with_parts(request)
                    .await
                    .map(|(_, resp)| resp)
            }

            /// Call to `delete_car` including response parts.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn delete_car_with_parts(
                &self,
                request: requests::DeleteCarRequest,
            ) -> Result<(http::response::Parts, responses::DeleteCarResponse)> {
                let mut uri = format!(
                    "{}://{}/v1/spaces/{}/car-service/cars/{}",
                    self.base_uri.scheme_str().unwrap(),
                    self.base_uri.authority().unwrap(),
                    lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?,
                    lgn_online::codegen::encoding::to_percent_encoded_string(&request.car_id)?
                );

                debug!("delete_car: {}", uri);

                let body = hyper::Body::empty();
                let mut req = Request::builder()
                    .method(hyper::Method::DELETE)
                    .uri(uri)
                    .body(body)?;

                let mut client = self.inner.clone();
                let resp = client.call(req).await.map_err(Into::into)?;

                responses::DeleteCarResponse::from_response(resp).await
            }

            /// Call to `test_binary`.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn test_binary(
                &self,
                request: requests::TestBinaryRequest,
            ) -> Result<responses::TestBinaryResponse> {
                self.test_binary_with_parts(request)
                    .await
                    .map(|(_, resp)| resp)
            }

            /// Call to `test_binary` including response parts.
            ///
            /// # Errors
            ///
            /// Returns an error in case of failure.
            pub async fn test_binary_with_parts(
                &self,
                request: requests::TestBinaryRequest,
            ) -> Result<(http::response::Parts, responses::TestBinaryResponse)> {
                let mut uri = format!(
                    "{}://{}/v1/spaces/{}/car-service/test-binary",
                    self.base_uri.scheme_str().unwrap(),
                    self.base_uri.authority().unwrap(),
                    lgn_online::codegen::encoding::to_percent_encoded_string(&request.space_id)?
                );

                debug!("test_binary: {}", uri);

                let body = hyper::Body::from(request.body);

                let mut req = Request::builder()
                    .method(hyper::Method::POST)
                    .uri(uri)
                    .body(body)?;

                req.headers_mut().insert(
                    CONTENT_TYPE,
                    HeaderValue::from_static("application/octet-stream"),
                );
                let mut client = self.inner.clone();
                let resp = client.call(req).await.map_err(Into::into)?;

                responses::TestBinaryResponse::from_response(resp).await
            }
        }
    }

    // ---------- Server ----------
    pub mod server {

        use super::{params, requests};
        use axum::{
            extract::ConnectInfo,
            extract::Json,
            extract::Path,
            http::Request,
            response::{IntoResponse, Response},
            routing, Extension, Router,
        };
        use http::header::HeaderName;
        use http::request::Parts;
        use lgn_online::{
            codegen::Bytes,
            server::{Error, Result},
        };
        use lgn_tracing::error;
        use serde_qs::axum::QsQuery;
        use std::net::SocketAddr;

        /// Register all the routes for that API to the specified Router.
        #[must_use]
        pub fn register_routes<T>(router: Router, api: T) -> Router
        where
            T: super::Api + Clone + Send + Sync + 'static,
        {
            router
                .route("/test-headers", routing::get(test_headers::<T>))
                .route("/test-one-of", routing::get(test_one_of::<T>))
                .route(
                    "/v1/spaces/:space-id/car-service/cars",
                    routing::get(get_cars::<T>).post(create_car::<T>),
                )
                .route(
                    "/v1/spaces/:space-id/car-service/cars/:car-id",
                    routing::get(get_car::<T>).delete(delete_car::<T>),
                )
                .route(
                    "/v1/spaces/:space-id/car-service/test-binary",
                    routing::post(test_binary::<T>),
                )
                .layer(Extension(api))
        }

        async fn test_headers<T>(Extension(api): Extension<T>, parts: Parts) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            let x_string_header = parts
                .headers
                .get(HeaderName::from_static("x-string-header"))
                .map(|h| {
                    let s = h
                        .to_str()
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-string-header: {}", err))
                                .into_response()
                        })
                        .unwrap();

                    lgn_online::codegen::encoding::from_percent_encoded_string(s)
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-string-header: {}", err))
                                .into_response()
                        })
                        .unwrap()
                });

            let x_bytes_header = parts
                .headers
                .get(HeaderName::from_static("x-bytes-header"))
                .map(|h| {
                    let s = h
                        .to_str()
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-bytes-header: {}", err))
                                .into_response()
                        })
                        .unwrap();

                    lgn_online::codegen::encoding::from_percent_encoded_string(s)
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-bytes-header: {}", err))
                                .into_response()
                        })
                        .unwrap()
                });

            let x_int_header = parts
                .headers
                .get(HeaderName::from_static("x-int-header"))
                .map(|h| {
                    let s = h
                        .to_str()
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-int-header: {}", err))
                                .into_response()
                        })
                        .unwrap();

                    lgn_online::codegen::encoding::from_percent_encoded_string(s)
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: x-int-header: {}", err))
                                .into_response()
                        })
                        .unwrap()
                });

            let request = requests::TestHeadersRequest {
                x_string_header,
                x_bytes_header,
                x_int_header,
            };

            match api.test_headers(parts, request).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }

        async fn test_one_of<T>(Extension(api): Extension<T>, parts: Parts) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            match api.test_one_of(parts).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }

        async fn get_cars<T>(
            Extension(api): Extension<T>,
            Path(space_id): Path<String>,
            QsQuery(query): QsQuery<params::GetCarsQuery>,
            parts: Parts,
        ) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            let request = requests::GetCarsRequest {
                space_id,
                names: query.names,
                q: query.q,
            };

            match api.get_cars(parts, request).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }

        async fn create_car<T>(
            Extension(api): Extension<T>,
            Path(space_id): Path<String>,
            Json(body): Json<super::super::components::Car>,
            parts: Parts,
        ) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            let span_id = parts
                .headers
                .get(HeaderName::from_static("span-id"))
                .map(|h| {
                    let s = h
                        .to_str()
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: span-id: {}", err))
                                .into_response()
                        })
                        .unwrap();

                    lgn_online::codegen::encoding::from_percent_encoded_string(s)
                        .map_err(|err| {
                            Error::BadRequest(format!("invalid header: span-id: {}", err))
                                .into_response()
                        })
                        .unwrap()
                });

            let request = requests::CreateCarRequest {
                space_id,
                span_id,
                body,
            };

            match api.create_car(parts, request).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }

        async fn get_car<T>(
            Extension(api): Extension<T>,
            Path((space_id, car_id)): Path<(String, i64)>,
            parts: Parts,
        ) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            let request = requests::GetCarRequest { space_id, car_id };

            match api.get_car(parts, request).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }

        async fn delete_car<T>(
            Extension(api): Extension<T>,
            Path((space_id, car_id)): Path<(String, i64)>,
            parts: Parts,
        ) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            let request = requests::DeleteCarRequest { space_id, car_id };

            match api.delete_car(parts, request).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }

        async fn test_binary<T>(
            Extension(api): Extension<T>,
            Path(space_id): Path<String>,
            body: axum::body::Bytes,
            parts: Parts,
        ) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            let request = requests::TestBinaryRequest {
                space_id,
                body: body.into(),
            };

            match api.test_binary(parts, request).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }
    }

    // ---------- Params ----------
    pub(crate) mod params {

        // Types used server side by axum to parse the request body.

        #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
        pub struct GetCarsQuery {
            #[serde(rename = "names")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub names: Option<Vec<String>>,
            #[serde(rename = "q")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pub q: Option<String>,
        }
    }

    // ---------- Requests ----------
    pub mod requests {

        use lgn_online::codegen::Bytes;

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct TestHeadersRequest {
            pub x_string_header: Option<String>,
            pub x_bytes_header: Option<Bytes>,
            pub x_int_header: Option<i32>,
        }

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct GetCarsRequest {
            pub space_id: String,
            pub names: Option<Vec<String>>,
            pub q: Option<String>,
        }

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct CreateCarRequest {
            pub space_id: String,
            pub span_id: Option<String>,
            pub body: super::super::components::Car,
        }

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct GetCarRequest {
            pub space_id: String,
            pub car_id: i64,
        }

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct DeleteCarRequest {
            pub space_id: String,
            pub car_id: i64,
        }

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct TestBinaryRequest {
            pub space_id: String,
            pub body: Bytes,
        }
    }

    // ---------- Responses ----------
    pub mod responses {

        use axum::{
            http::StatusCode,
            response::{IntoResponse, Response},
            Json,
        };
        use http::HeaderMap;
        use http::HeaderValue;
        use lgn_online::{
            codegen::Bytes,
            server::{Error, Result},
        };

        #[derive(Debug)]
        pub enum TestHeadersResponse {
            /// Ok.
            Status200 {
                x_bytes_header: Bytes,
                x_int_header: i32,
                x_string_header: String,
                body: super::super::components::Pet,
            },
            WithHeaders(http::HeaderMap, Box<TestHeadersResponse>),
            WithExtensions(http::Extensions, Box<TestHeadersResponse>),
        }

        impl TestHeadersResponse {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s)),
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s)),
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(
                self,
                key: impl http::header::IntoHeaderName,
                val: http::header::HeaderValue,
            ) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    Self::Status200 {
                        x_bytes_header,
                        x_int_header,
                        x_string_header,
                        body,
                    } => {
                        let body = Json(body);
                        let mut resp = (StatusCode::from_u16(200).unwrap(), body).into_response();
                        let x_bytes_header_value =
                            match lgn_online::codegen::encoding::to_percent_encoded_string(
                                &x_bytes_header,
                            ) {
                                Ok(value) => value,
                                Err(err) => {
                                    return Error::Internal(format!(
                                        "failed to serialize header: x-bytes-header: {}",
                                        err
                                    ))
                                    .into_response();
                                }
                            };
                        match HeaderValue::from_str(&x_bytes_header_value) {
                            Ok(value) => resp.headers_mut().insert("x-bytes-header", value),
                            Err(err) => {
                                return Error::Internal(format!(
                                    "failed to serialize header: x-bytes-header: {}",
                                    err
                                ))
                                .into_response();
                            }
                        };
                        let x_int_header_value =
                            match lgn_online::codegen::encoding::to_percent_encoded_string(
                                &x_int_header,
                            ) {
                                Ok(value) => value,
                                Err(err) => {
                                    return Error::Internal(format!(
                                        "failed to serialize header: x-int-header: {}",
                                        err
                                    ))
                                    .into_response();
                                }
                            };
                        match HeaderValue::from_str(&x_int_header_value) {
                            Ok(value) => resp.headers_mut().insert("x-int-header", value),
                            Err(err) => {
                                return Error::Internal(format!(
                                    "failed to serialize header: x-int-header: {}",
                                    err
                                ))
                                .into_response();
                            }
                        };
                        let x_string_header_value =
                            match lgn_online::codegen::encoding::to_percent_encoded_string(
                                &x_string_header,
                            ) {
                                Ok(value) => value,
                                Err(err) => {
                                    return Error::Internal(format!(
                                        "failed to serialize header: x-string-header: {}",
                                        err
                                    ))
                                    .into_response();
                                }
                            };
                        match HeaderValue::from_str(&x_string_header_value) {
                            Ok(value) => resp.headers_mut().insert("x-string-header", value),
                            Err(err) => {
                                return Error::Internal(format!(
                                    "failed to serialize header: x-string-header: {}",
                                    err
                                ))
                                .into_response();
                            }
                        };
                        resp
                    }

                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(
                resp: http::Response<ResBody>,
            ) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::server::StdError>,
            {
                let (mut parts, body) = resp.into_parts();

                match parts.status.as_u16() {
                    200 => {
                        let x_bytes_header =
                            lgn_online::codegen::encoding::from_percent_encoded_string(
                                parts
                                    .headers
                                    .remove("x-bytes-header")
                                    .ok_or_else(|| {
                                        Error::Internal("missing header: x-bytes-header".to_owned())
                                    })?
                                    .to_str()
                                    .map_err(|e| {
                                        Error::Internal(format!(
                                            "invalid header: x-bytes-header: {}",
                                            e
                                        ))
                                    })?,
                            )?;
                        let x_int_header =
                            lgn_online::codegen::encoding::from_percent_encoded_string(
                                parts
                                    .headers
                                    .remove("x-int-header")
                                    .ok_or_else(|| {
                                        Error::Internal("missing header: x-int-header".to_owned())
                                    })?
                                    .to_str()
                                    .map_err(|e| {
                                        Error::Internal(format!(
                                            "invalid header: x-int-header: {}",
                                            e
                                        ))
                                    })?,
                            )?;
                        let x_string_header =
                            lgn_online::codegen::encoding::from_percent_encoded_string(
                                parts
                                    .headers
                                    .remove("x-string-header")
                                    .ok_or_else(|| {
                                        Error::Internal(
                                            "missing header: x-string-header".to_owned(),
                                        )
                                    })?
                                    .to_str()
                                    .map_err(|e| {
                                        Error::Internal(format!(
                                            "invalid header: x-string-header: {}",
                                            e
                                        ))
                                    })?,
                            )?;
                        let bytes = hyper::body::to_bytes(body).await.map_err(Into::into)?;
                        let body = serde_json::from_slice(&bytes)?;
                        Ok((
                            parts,
                            Self::Status200 {
                                x_bytes_header,
                                x_int_header,
                                x_string_header,
                                body,
                            },
                        ))
                    }
                    status => Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        status
                    ))),
                }
            }
        }

        #[derive(Debug)]
        pub enum TestOneOfResponse {
            /// Ok.
            Status200(super::TestOneOf200Response),
            WithHeaders(http::HeaderMap, Box<TestOneOfResponse>),
            WithExtensions(http::Extensions, Box<TestOneOfResponse>),
        }

        impl TestOneOfResponse {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s)),
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s)),
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(
                self,
                key: impl http::header::IntoHeaderName,
                val: http::header::HeaderValue,
            ) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    Self::Status200(body) => {
                        let body = Json(body);
                        (StatusCode::from_u16(200).unwrap(), body).into_response()
                    }
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(
                resp: http::Response<ResBody>,
            ) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::server::StdError>,
            {
                let (mut parts, body) = resp.into_parts();

                match parts.status.as_u16() {
                    200 => {
                        let bytes = hyper::body::to_bytes(body).await.map_err(Into::into)?;
                        let body = serde_json::from_slice(&bytes)?;
                        Ok((parts, Self::Status200(body)))
                    }
                    status => Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        status
                    ))),
                }
            }
        }

        #[derive(Debug)]
        pub enum GetCarsResponse {
            /// List of cars.
            Status200(super::super::components::Cars),
            WithHeaders(http::HeaderMap, Box<GetCarsResponse>),
            WithExtensions(http::Extensions, Box<GetCarsResponse>),
        }

        impl GetCarsResponse {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s)),
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s)),
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(
                self,
                key: impl http::header::IntoHeaderName,
                val: http::header::HeaderValue,
            ) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    Self::Status200(body) => {
                        let body = Json(body);
                        (StatusCode::from_u16(200).unwrap(), body).into_response()
                    }
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(
                resp: http::Response<ResBody>,
            ) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::server::StdError>,
            {
                let (mut parts, body) = resp.into_parts();

                match parts.status.as_u16() {
                    200 => {
                        let bytes = hyper::body::to_bytes(body).await.map_err(Into::into)?;
                        let body = serde_json::from_slice(&bytes)?;
                        Ok((parts, Self::Status200(body)))
                    }
                    status => Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        status
                    ))),
                }
            }
        }

        #[derive(Debug)]
        pub enum CreateCarResponse {
            /// Created.
            Status201,
            WithHeaders(http::HeaderMap, Box<CreateCarResponse>),
            WithExtensions(http::Extensions, Box<CreateCarResponse>),
        }

        impl CreateCarResponse {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s)),
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s)),
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(
                self,
                key: impl http::header::IntoHeaderName,
                val: http::header::HeaderValue,
            ) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    Self::Status201 => StatusCode::from_u16(201).unwrap().into_response(),
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(
                resp: http::Response<ResBody>,
            ) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::server::StdError>,
            {
                let (mut parts, _body) = resp.into_parts();

                match parts.status.as_u16() {
                    201 => Ok((parts, Self::Status201)),
                    status => Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        status
                    ))),
                }
            }
        }

        #[derive(Debug)]
        pub enum GetCarResponse {
            /// A car.
            Status200(super::super::components::Car),
            /// Car not found.
            Status404,
            WithHeaders(http::HeaderMap, Box<GetCarResponse>),
            WithExtensions(http::Extensions, Box<GetCarResponse>),
        }

        impl GetCarResponse {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s)),
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s)),
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(
                self,
                key: impl http::header::IntoHeaderName,
                val: http::header::HeaderValue,
            ) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    Self::Status200(body) => {
                        let body = Json(body);
                        (StatusCode::from_u16(200).unwrap(), body).into_response()
                    }
                    Self::Status404 => StatusCode::from_u16(404).unwrap().into_response(),
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(
                resp: http::Response<ResBody>,
            ) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::server::StdError>,
            {
                let (mut parts, body) = resp.into_parts();

                match parts.status.as_u16() {
                    200 => {
                        let bytes = hyper::body::to_bytes(body).await.map_err(Into::into)?;
                        let body = serde_json::from_slice(&bytes)?;
                        Ok((parts, Self::Status200(body)))
                    }

                    404 => Ok((parts, Self::Status404)),
                    status => Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        status
                    ))),
                }
            }
        }

        #[derive(Debug)]
        pub enum DeleteCarResponse {
            /// Car deleted.
            Status200,
            /// Car not found.
            Status404,
            WithHeaders(http::HeaderMap, Box<DeleteCarResponse>),
            WithExtensions(http::Extensions, Box<DeleteCarResponse>),
        }

        impl DeleteCarResponse {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s)),
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s)),
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(
                self,
                key: impl http::header::IntoHeaderName,
                val: http::header::HeaderValue,
            ) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    Self::Status200 => StatusCode::from_u16(200).unwrap().into_response(),
                    Self::Status404 => StatusCode::from_u16(404).unwrap().into_response(),
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(
                resp: http::Response<ResBody>,
            ) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::server::StdError>,
            {
                let (mut parts, _body) = resp.into_parts();

                match parts.status.as_u16() {
                    200 => Ok((parts, Self::Status200)),

                    404 => Ok((parts, Self::Status404)),
                    status => Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        status
                    ))),
                }
            }
        }

        #[derive(Debug)]
        pub enum TestBinaryResponse {
            /// Ok.
            Status200(Bytes),
            WithHeaders(http::HeaderMap, Box<TestBinaryResponse>),
            WithExtensions(http::Extensions, Box<TestBinaryResponse>),
        }

        impl TestBinaryResponse {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s)),
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s)),
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(
                self,
                key: impl http::header::IntoHeaderName,
                val: http::header::HeaderValue,
            ) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    Self::Status200(body) => {
                        let body: Vec<u8> = body.into();
                        (StatusCode::from_u16(200).unwrap(), body).into_response()
                    }
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(
                resp: http::Response<ResBody>,
            ) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::server::StdError>,
            {
                let (mut parts, body) = resp.into_parts();

                match parts.status.as_u16() {
                    200 => {
                        let bytes = hyper::body::to_bytes(body).await.map_err(Into::into)?;
                        let body = bytes.into();
                        Ok((parts, Self::Status200(body)))
                    }
                    status => Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        status
                    ))),
                }
            }
        }
    }
}

// Models and API from: components

pub mod components {

    use lgn_online::{codegen::Bytes, server::Error};

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Car {
        #[serde(rename = "color")]
        pub color: CarColor,

        #[serde(rename = "extra")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub extra: Option<Bytes>,

        #[serde(rename = "id")]
        pub id: i64,

        #[serde(rename = "is_new")]
        pub is_new: bool,

        #[serde(rename = "name")]
        pub name: String,
    }

    /// The car color.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub enum CarColor {
        #[serde(rename = "red")]
        Red,
        #[serde(rename = "blue")]
        Blue,
        #[serde(rename = "yellow")]
        Yellow,
    }

    impl std::str::FromStr for CarColor {
        type Err = Error;

        fn from_str(s: &str) -> Result<Self, <CarColor as std::str::FromStr>::Err> {
            match s {
                "Red" => Ok(Self::Red),
                "Blue" => Ok(Self::Blue),
                "Yellow" => Ok(Self::Yellow),
                _ => Err(Error::Internal(format!("unknown enum value {}", s))),
            }
        }
    }

    impl TryFrom<u32> for CarColor {
        type Error = Error;

        fn try_from(n: u32) -> Result<Self, <CarColor as TryFrom<u32>>::Error> {
            match n {
                0 => Ok(Self::Red),
                1 => Ok(Self::Blue),
                2 => Ok(Self::Yellow),
                _ => Err(Error::Internal(format!(
                    "index out of bound {}, accepted index between 0 and 2",
                    n
                ))),
            }
        }
    }

    impl TryFrom<i32> for CarColor {
        type Error = Error;

        fn try_from(n: i32) -> Result<Self, <CarColor as TryFrom<i32>>::Error> {
            match n {
                0 => Ok(Self::Red),
                1 => Ok(Self::Blue),
                2 => Ok(Self::Yellow),
                _ => Err(Error::Internal(format!(
                    "index out of bound {}, accepted index between 0 and 2",
                    n
                ))),
            }
        }
    }

    impl ToString for CarColor {
        fn to_string(&self) -> String {
            match self {
                Self::Red => "Red",
                Self::Blue => "Blue",
                Self::Yellow => "Yellow",
            }
            .into()
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Cars(pub Vec<Car>);

    impl From<Vec<Car>> for Cars {
        fn from(t: Vec<Car>) -> Self {
            Self(t)
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Pet {
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
    }
}

pub fn register_routes<S: cars::Api + Clone + Send + Sync + 'static>(
    router: axum::Router,
    server: S,
) -> axum::Router {
    cars::server::register_routes(router, server)
}

