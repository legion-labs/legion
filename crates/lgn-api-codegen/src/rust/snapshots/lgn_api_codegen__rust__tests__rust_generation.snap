---
source: crates/lgn-api-codegen/src/rust/mod.rs
expression: content
---
// Auto-generated file for Api: Test API : 1.0.0
//
// This is a sample OpenAPI 3.0 specification.
//

// ---------- Api ----------
use errors::Result;
use lgn_online::codegen::Context;

#[async_trait::async_trait]
pub trait Api {
    async fn get_cars(
        &self,
        context: &mut Context,
        request: requests::GetCarsRequest,
    ) -> Result<responses::GetCarsResponse>;

    async fn create_car(
        &self,
        context: &mut Context,
        request: requests::CreateCarRequest,
    ) -> Result<responses::CreateCarResponse>;

    async fn get_car(
        &self,
        context: &mut Context,
        request: requests::GetCarRequest,
    ) -> Result<responses::GetCarResponse>;

    async fn test_binary(
        &self,
        context: &mut Context,
        request: requests::TestBinaryRequest,
    ) -> Result<responses::TestBinaryResponse>;

    async fn test_one_of(
        &self,
        context: &mut Context,
        request: requests::TestOneOfRequest,
    ) -> Result<responses::TestOneOfResponse>;
}

// ---------- Errors ----------
pub mod errors {
    use axum::{
        http::StatusCode,
        response::{IntoResponse, Response},
    };
    use lgn_tracing::error;

    #[derive(thiserror::Error, Debug)]
    pub enum Error {
        #[error("internal: {0}")]
        Internal(String),
        #[error("hyper: {0}")]
        Hyper(#[from] hyper::Error),
        #[error("serde json: {0}")]
        SerdeJson(#[from] serde_json::Error),
        #[error("serde qs: {0}")]
        SerdeQs(#[from] serde_qs::Error),
        #[error("invalid body: {0}")]
        InvalidBody(String),
        #[error("invalid header: {0}")]
        InvalidHeader(String),
        #[error("missing header: {0}")]
        MissingHeader(String),
    }

    pub type Result<T> = std::result::Result<T, Error>;

    impl IntoResponse for Error {
        fn into_response(self) -> Response {
            match self {
                Self::Internal(err) => {
                    error!("Internal server error: {}", err);
                    StatusCode::INTERNAL_SERVER_ERROR.into_response()
                }
                Self::Hyper(err) => {
                    error!("Hyper error: {:?}", err);
                    StatusCode::INTERNAL_SERVER_ERROR.into_response()
                }
                Self::SerdeJson(err) => {
                    error!("Serde Json error: {:?}", err);
                    StatusCode::INTERNAL_SERVER_ERROR.into_response()
                }
                Self::SerdeQs(err) => {
                    error!("Serde Qs error: {:?}", err);
                    StatusCode::INTERNAL_SERVER_ERROR.into_response()
                }
                Self::InvalidBody(err) => {
                    error!("Invalid body: {}", err);
                    StatusCode::BAD_REQUEST.into_response()
                }
                Self::InvalidHeader(err) => {
                    error!("Invalid header: {}", err);
                    StatusCode::BAD_REQUEST.into_response()
                }
                Self::MissingHeader(err) => {
                    error!("Missing header: {}", err);
                    StatusCode::BAD_REQUEST.into_response()
                }
            }
        }
    }
}

// ---------- Client ----------
pub mod client {
    use super::{
        errors::{Error, Result},
        params, requests, responses,
    };
    use http::{header::CONTENT_TYPE, HeaderValue};
    use hyper::{Body, Method, Request};
    use lgn_online::codegen::{Bytes, Context};

    pub struct Client<C> {
        inner: hyper::Client<C>,
        base_uri: String,
    }

    impl<C> Client<C> {
        pub fn new(inner: hyper::Client<C>, base_uri: &str) -> Self {
            Self {
                inner,
                base_uri: base_uri.to_string(),
            }
        }
    }

    #[async_trait::async_trait]
    impl<C> super::Api for Client<C>
    where
        C: hyper::client::connect::Connect + Clone + Send + Sync + 'static,
    {
        async fn get_cars(
            &self,
            context: &mut Context,
            request: requests::GetCarsRequest,
        ) -> Result<responses::GetCarsResponse> {
            let mut uri = format!(
                "{}/spaces/{}/car-service/cars",
                self.base_uri, request.space_id
            );

            let query = params::GetCarsQuery {
                names: request.names,
                q: request.q,
            };
            let query_string = serde_qs::to_string(&query)?;
            if !query_string.is_empty() {
                uri += &format!("?{}", query_string);
            }
            let mut req = Request::builder()
                .method(Method::GET)
                .uri(uri)
                .body(Body::empty())
                .unwrap();
            let resp = self.inner.request(req).await?;

            let (resp_parts, resp_body) = resp.into_parts();
            let resp_status = resp_parts.status;
            context.set_response(resp_parts.into());

            responses::GetCarsResponse::from_response(resp_status, resp_body).await
        }

        async fn create_car(
            &self,
            context: &mut Context,
            request: requests::CreateCarRequest,
        ) -> Result<responses::CreateCarResponse> {
            let mut uri = format!(
                "{}/spaces/{}/car-service/cars",
                self.base_uri, request.space_id
            );

            let mut req = Request::builder()
                .method(Method::POST)
                .uri(uri)
                .body(Body::from(serde_json::to_string(&request.body)?))
                .map_err(|err| Error::InvalidBody(err.to_string()))?;

            req.headers_mut()
                .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
            let resp = self.inner.request(req).await?;

            let (resp_parts, resp_body) = resp.into_parts();
            let resp_status = resp_parts.status;
            context.set_response(resp_parts.into());

            responses::CreateCarResponse::from_response(resp_status, resp_body).await
        }

        async fn get_car(
            &self,
            context: &mut Context,
            request: requests::GetCarRequest,
        ) -> Result<responses::GetCarResponse> {
            let mut uri = format!(
                "{}/spaces/{}/car-service/cars/{}",
                self.base_uri, request.space_id, request.car_id
            );

            let mut req = Request::builder()
                .method(Method::GET)
                .uri(uri)
                .body(Body::empty())
                .unwrap();
            let resp = self.inner.request(req).await?;

            let (resp_parts, resp_body) = resp.into_parts();
            let resp_status = resp_parts.status;
            context.set_response(resp_parts.into());

            responses::GetCarResponse::from_response(resp_status, resp_body).await
        }

        async fn test_binary(
            &self,
            context: &mut Context,
            request: requests::TestBinaryRequest,
        ) -> Result<responses::TestBinaryResponse> {
            let mut uri = format!(
                "{}/spaces/{}/car-service/test-binary",
                self.base_uri, request.space_id
            );

            let mut req = Request::builder()
                .method(Method::POST)
                .uri(uri)
                .body(Body::from(request.body))
                .map_err(|err| Error::InvalidBody(err.to_string()))?;

            req.headers_mut().insert(
                CONTENT_TYPE,
                HeaderValue::from_static("application/octet-stream"),
            );
            let resp = self.inner.request(req).await?;

            let (resp_parts, resp_body) = resp.into_parts();
            let resp_status = resp_parts.status;
            context.set_response(resp_parts.into());

            responses::TestBinaryResponse::from_response(resp_status, resp_body).await
        }

        async fn test_one_of(
            &self,
            context: &mut Context,
            request: requests::TestOneOfRequest,
        ) -> Result<responses::TestOneOfResponse> {
            let mut uri = format!("{}/test-one-of", self.base_uri);

            let mut req = Request::builder()
                .method(Method::GET)
                .uri(uri)
                .body(Body::empty())
                .unwrap();
            let resp = self.inner.request(req).await?;

            let (resp_parts, resp_body) = resp.into_parts();
            let resp_status = resp_parts.status;
            context.set_response(resp_parts.into());

            responses::TestOneOfResponse::from_response(resp_status, resp_body).await
        }
    }
}

// ---------- Server ----------
pub mod server {
    use super::errors::{Error, Result};
    use super::params;
    use super::requests;
    use axum::{
        extract::Json,
        extract::Path,
        http::Request,
        response::{IntoResponse, Response},
        routing, Extension, Router,
    };
    use http::header::HeaderName;
    use http::request::Parts;
    use lgn_online::codegen::{Bytes, Context};
    use lgn_tracing::error;
    use serde_qs::axum::QsQuery;

    /// Register all the routes for that API to the specified Router.
    #[must_use]
    pub fn register_routes<T>(router: Router, api: T) -> Router
    where
        T: super::Api + Clone + Send + Sync + 'static,
    {
        router
            .route(
                "/spaces/:space-id/car-service/cars",
                routing::get(get_cars::<T>).post(create_car::<T>),
            )
            .route(
                "/spaces/:space-id/car-service/cars/:car-id",
                routing::get(get_car::<T>),
            )
            .route(
                "/spaces/:space-id/car-service/test-binary",
                routing::post(test_binary::<T>),
            )
            .route("/test-one-of", routing::get(test_one_of::<T>))
            .layer(Extension(api))
    }

    async fn get_cars<T>(
        Extension(api): Extension<T>,
        Path(space_id): Path<String>,
        QsQuery(query): QsQuery<params::GetCarsQuery>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::from(Some(parts.into()), None);
        let request = requests::GetCarsRequest {
            space_id,
            names: query.names,
            q: query.q,
        };

        let resp = api.get_cars(&mut context, request).await;
        match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        }
    }

    async fn create_car<T>(
        Extension(api): Extension<T>,
        Path(space_id): Path<String>,
        Json(body): Json<super::models::Car>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::from(Some(parts.into()), None);
        let request = requests::CreateCarRequest { space_id, body };

        let resp = api.create_car(&mut context, request).await;
        match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        }
    }

    async fn get_car<T>(
        Extension(api): Extension<T>,
        Path((space_id, car_id)): Path<(String, i64)>,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::from(Some(parts.into()), None);
        let request = requests::GetCarRequest { space_id, car_id };

        let resp = api.get_car(&mut context, request).await;
        match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        }
    }

    async fn test_binary<T>(
        Extension(api): Extension<T>,
        Path(space_id): Path<String>,
        body: axum::body::Bytes,
        parts: Parts,
    ) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::from(Some(parts.into()), None);
        let request = requests::TestBinaryRequest {
            space_id,
            body: body.into(),
        };

        let resp = api.test_binary(&mut context, request).await;
        match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        }
    }

    async fn test_one_of<T>(Extension(api): Extension<T>, parts: Parts) -> Response
    where
        T: super::Api + Send + Sync + 'static,
    {
        let mut context = Context::from(Some(parts.into()), None);
        let request = requests::TestOneOfRequest {};

        let resp = api.test_one_of(&mut context, request).await;
        match resp {
            Ok(resp) => resp.into_response(),
            Err(err) => err.into_response(),
        }
    }
}

// ---------- Models ----------
pub mod models {
    use lgn_online::codegen::Bytes;

    /// The car color.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub enum CarColor {
        #[serde(rename = "red")]
        Red,
        #[serde(rename = "blue")]
        Blue,
        #[serde(rename = "yellow")]
        Yellow,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Car {
        #[serde(rename = "id")]
        pub id: i64,

        #[serde(rename = "name")]
        pub name: String,
        /// The car color.
        #[serde(rename = "color")]
        pub color: super::models::CarColor,

        #[serde(rename = "is_new")]
        pub is_new: bool,

        #[serde(rename = "extra")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub extra: Option<Bytes>,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct Pet {
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub name: Option<String>,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub enum TestOneOfResponse {
        #[serde(rename = "option1")]
        Option1(super::models::Pet),
        #[serde(rename = "option2")]
        Option2(super::models::Car),
    }
}

// ---------- Params ----------
pub(crate) mod params {
    // Types used server side by axum to parse the request body.

    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
    pub struct GetCarsQuery {
        #[serde(rename = "names")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub names: Option<Vec<String>>,
        #[serde(rename = "q")]
        #[serde(skip_serializing_if = "Option::is_none")]
        pub q: Option<String>,
    }
}

// ---------- Requests ----------
pub mod requests {
    use lgn_online::codegen::Bytes;

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct GetCarsRequest {
        pub space_id: String,
        pub names: Option<Vec<String>>,
        pub q: Option<String>,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct CreateCarRequest {
        pub space_id: String,
        pub body: super::models::Car,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct GetCarRequest {
        pub space_id: String,
        pub car_id: i64,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct TestBinaryRequest {
        pub space_id: String,
        pub body: Bytes,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct TestOneOfRequest {}
}

// ---------- Responses ----------
pub mod responses {
    use super::errors::{Error, Result};
    use axum::{
        http::StatusCode,
        response::{IntoResponse, Response},
        Json,
    };
    use lgn_online::codegen::Bytes;

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum GetCarsResponse {
        /// List of cars.
        Status200(GetCars200Response),
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct GetCars200Response {
        pub body: Vec<super::models::Car>,
    }

    impl GetCarsResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                GetCarsResponse::Status200(r) => {
                    let body = Json(r.body);
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let resp = GetCars200Response {
                        body: serde_json::from_slice(&bytes)?,
                    };
                    Ok(Self::Status200(resp))
                }
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum CreateCarResponse {
        /// Created.
        Status201(CreateCar201Response),
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct CreateCar201Response {
        pub body: super::models::Car,
    }

    impl CreateCarResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                CreateCarResponse::Status201(r) => {
                    let body = Json(r.body);
                    (StatusCode::from_u16(201).unwrap(), body).into_response()
                }
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                201 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let resp = CreateCar201Response {
                        body: serde_json::from_slice(&bytes)?,
                    };
                    Ok(Self::Status201(resp))
                }
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum GetCarResponse {
        /// A car.
        Status200(GetCar200Response),
        /// Car not found.
        Status404,
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct GetCar200Response {
        pub body: super::models::Car,
    }

    impl GetCarResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                GetCarResponse::Status200(r) => {
                    let body = Json(r.body);
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
                GetCarResponse::Status404 => StatusCode::from_u16(404).unwrap().into_response(),
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let resp = GetCar200Response {
                        body: serde_json::from_slice(&bytes)?,
                    };
                    Ok(Self::Status200(resp))
                }

                404 => Ok(Self::Status404),
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum TestBinaryResponse {
        /// Ok.
        Status200(TestBinary200Response),
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct TestBinary200Response {
        pub body: Bytes,
    }

    impl TestBinaryResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                TestBinaryResponse::Status200(r) => {
                    let body: Vec<u8> = r.body.into();
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let resp = TestBinary200Response { body: bytes.into() };
                    Ok(Self::Status200(resp))
                }
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum TestOneOfResponse {
        /// Ok.
        Status200(TestOneOf200Response),
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct TestOneOf200Response {
        pub body: super::models::TestOneOfResponse,
    }

    impl TestOneOfResponse {
        pub(crate) fn into_response(self) -> Response {
            match self {
                TestOneOfResponse::Status200(r) => {
                    let body = Json(r.body);
                    (StatusCode::from_u16(200).unwrap(), body).into_response()
                }
            }
        }

        pub(crate) async fn from_response(status: StatusCode, body: hyper::Body) -> Result<Self> {
            match status.as_u16() {
                200 => {
                    let bytes = hyper::body::to_bytes(body).await?;
                    let resp = TestOneOf200Response {
                        body: serde_json::from_slice(&bytes)?,
                    };
                    Ok(Self::Status200(resp))
                }
                status => Err(Error::Internal(format!(
                    "unexpected status code: {}",
                    status
                ))),
            }
        }
    }
}

