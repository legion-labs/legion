use axum::{
    extract::ConnectInfo,
    extract::Json,
    extract::Path,
    http::Request,
    response::{IntoResponse, Response},
    routing,
    Extension,
    Router,
};
use http::{HeaderMap, HeaderValue, Extensions, request::Parts, header::HeaderName};

use std::net::SocketAddr;
use serde_qs::axum::QsQuery;
use lgn_online::server::{Error, Result};
use lgn_tracing::error;

{% for (path, routes) in api.paths %}
    {% for route in routes %}
        {% if !route.parameters.query.is_empty() -%}
            #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
            struct {{ route.name|pascal_case }}Query {
                {% for parameter in route.parameters.query -%}
                    #[serde(rename = "{{ parameter.name }}")]
                    {%- if parameter.required -%}
                        {{ parameter.name|snake_case }}: {{ parameter.type_|fmt_type(ctx, module_path) }},
                    {%- else -%}
                        #[serde(skip_serializing_if = "Option::is_none")]
                        {{ parameter.name|snake_case }}: Option<{{ parameter.type_|fmt_type(ctx, module_path) }}>,
                    {%- endif -%}
                {% endfor -%}
            }
        {% endif %}

        // Request type.
        {% let request_type = "{}Request"|format(route.name|pascal_case) %}

        #[derive(Debug)]
        pub struct {{ request_type }} {
            {% for parameter in route.parameters -%}
                {%- if parameter.required -%}
                    pub {{ parameter.name|snake_case }}: {{ parameter.type_|fmt_type(ctx, module_path) }},
                {%- else -%}
                    pub {{ parameter.name|snake_case }}: Option<{{ parameter.type_|fmt_type(ctx, module_path) }}>,
                {%- endif -%}
            {% endfor -%}
            {% if let Some(request_body) = route.request_body -%}
                {%- if request_body.required -%}
                    pub body: {{ request_body.content.type_|fmt_type(ctx, module_path) }},
                {%- else -%}
                    pub body: Option<{{ request_body.content.type_|fmt_type(ctx, module_path) }}>,
                {%- endif -%}
            {% endif -%}
            pub parts: http::request::Parts,
        }

        // Response type.
        {% let response_type = "{}Response"|format(route.name|pascal_case) %}

        #[derive(Debug)]
        pub enum {{ response_type }} {
            {% for (status_code, response) in route.responses -%}
                /// {{ response.description }}
                {% if !response.headers.is_empty() -%}
                    Status{{ status_code }}{
                        {% for (header_name, header) in response.headers -%}
                            {{ header_name|snake_case }}: {{ header.type_|fmt_type(ctx, module_path) }},
                        {% endfor -%}
                        {% if let Some(content) = response.content -%}
                            body: {{ content.type_|fmt_type(ctx, module_path) }},
                        {% endif -%}
                    },
                {% else if let Some(content) = response.content -%}
                    Status{{ status_code }}({{ content.type_|fmt_type(ctx, module_path) }}),
                {% else -%}
                    Status{{ status_code }},
                {% endif -%}
            {% endfor -%}
            WithHeaders(HeaderMap, Box<{{ response_type }}>),
            WithExtensions(Extensions, Box<{{ response_type }}>),
        }

        impl {{ response_type }} {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s))
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s))
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(self, key: impl http::header::IntoHeaderName, val: http::header::HeaderValue) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    {% for (status_code, response) in route.responses %}
                        {% if !response.headers.is_empty() -%}
                            Self::Status{{ status_code }}{
                                {% for (header_name, header) in response.headers -%}
                                    {{ header_name|snake_case }},
                                {% endfor -%}
                                {% if let Some(content) = response.content -%}
                                    body,
                                {% endif -%}
                            } => {
                                    {% if let Some(content) = response.content -%}
                                        {% match content.media_type -%}
                                            {% when MediaType::Json -%}
                                                let body = Json(body);
                                            {% when MediaType::Bytes -%}
                                                let body: Vec<u8> = body.into();
                                        {% endmatch -%}
                                    {% else -%}
                                        let body = bytes::Bytes::new();
                                    {% endif -%}
                                    let mut resp = (axum::http::StatusCode::from_u16({{ status_code.as_u16() }}).unwrap(), body).into_response();
                                    {% for (header_name, header) in response.headers -%}
                                        let {{ header_name|snake_case }}_value = match lgn_online::codegen::encoding::to_percent_encoded_string(&{{ header_name|snake_case }}){
                                            Ok(value) => value,
                                            Err(err) => {
                                                return Error::internal(format!("failed to serialize header: {{ header_name }}: {}", err)).into_response();
                                            },
                                        };
                                        match HeaderValue::from_str(&{{ header_name|snake_case }}_value){
                                            Ok(value) => resp.headers_mut().insert("{{ header_name }}", value),
                                            Err(err) => {
                                                return Error::internal(format!("failed to serialize header: {{ header_name }}: {}", err)).into_response();
                                            },
                                        };
                                    {% endfor -%}
                                    resp
                            },
                        {% else if let Some(content) = response.content -%}
                            Self::Status{{ status_code }}(body) => {
                                    {% match content.media_type -%}
                                        {% when MediaType::Json -%}
                                            let body = Json(body);
                                        {% when MediaType::Bytes -%}
                                            let body: Vec<u8> = body.into();
                                    {% endmatch -%}
                                    (axum::http::StatusCode::from_u16({{ status_code.as_u16() }}).unwrap(), body).into_response()
                            },
                        {%- else -%}
                            Self::Status{{ status_code }} => {
                                axum::http::StatusCode::from_u16({{ status_code.as_u16() }}).unwrap().into_response()
                            },
                        {%- endif -%}
                    {% endfor %}
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }
        }

        async fn {{ route.name|snake_case }}<T>(
            Extension(api): Extension<T>,
            {% if !route.parameters.path.is_empty() -%}
                Path({{ route.parameters.path|join_names }}): Path<{{ route.parameters.path|join_types(ctx, module_path) }}>,
            {% endif -%}
            {% if !route.parameters.query.is_empty() -%}
                QsQuery(query): QsQuery<{{ route.name|pascal_case }}Query>,
            {% endif -%}
            {% if let Some(request_body) = route.request_body -%}
                {% match request_body.content.media_type -%}
                    {% when MediaType::Json -%}
                        {%- if request_body.required -%}
                            Json(body): Json<{{ request_body.content.type_|fmt_type(ctx, module_path) }}>,
                        {%- else -%}
                            Json(body): Json<Option<{{ request_body.content.type_|fmt_type(ctx, module_path) }}>>,
                        {%- endif -%}
                    {% when MediaType::Bytes -%}
                        body: axum::body::Bytes,
                {% endmatch -%}
            {% endif -%}
            parts: Parts,
        ) -> Response
        where
            T: super::Api + Send + Sync + 'static,
        {
            {%- for parameter in route.parameters.header -%}
            {% let param_name = "{}"|format(parameter.name|snake_case) %}
                let {{ param_name }} = parts.headers
                    .get(HeaderName::from_static("{{ parameter.name }}"))
                    .map(|h| {
                        let s = h.to_str()
                        .map_err(|err| {
                            Error::bad_request(format!("invalid header: {{ parameter.name }}: {}", err)).into_response()
                        })
                        .unwrap();

                        lgn_online::codegen::encoding::from_percent_encoded_string(s)
                        .map_err(|err| {
                            Error::bad_request(format!("invalid header: {{ parameter.name }}: {}", err)).into_response()
                        })
                        .unwrap()
                });

                {% if parameter.required %}
                    if {{ param_name }}.is_none() {
                        return Error::bad_request("missing header: {{ parameter.name }}".to_owned()).into_response();
                    }
                    let {{ param_name }} = {{ param_name }}.unwrap();
                {% endif %}
            {% endfor %}

            let request = {{ request_type }} {
                {%- for parameter in route.parameters.path -%}
                    {{ parameter.name|snake_case }},
                {%- endfor -%}
                {%- for parameter in route.parameters.query -%}
                    {{ parameter.name|snake_case }}: query.{{ parameter.name|snake_case }},
                {%- endfor -%}
                {%- for parameter in route.parameters.header -%}
                    {{ parameter.name|snake_case }},
                {%- endfor -%}
                {%- if let Some(request_body) = route.request_body -%}
                    {% match request_body.content.media_type -%}
                        {% when MediaType::Json -%}
                            body,
                        {% when MediaType::Bytes -%}
                            body: body.into(),
                    {% endmatch -%}
                {%- endif -%}
                parts,
            };

            match api.{{ route.name|snake_case }}(request).await {
                Ok(resp) => resp.into_response(),
                Err(err) => err.into_response(),
            }
        }
    {% endfor %}
{% endfor %}

/// Register all the routes for that API to the specified Router.
#[must_use]
pub fn register_routes<T>(router: Router, api: T) -> Router
where
    T: super::Api + Clone + Send + Sync + 'static,
{
    router
    {%- for (path, routes) in api.paths -%}
        .route("{{ path|fmt_axum_path }}",
            {% for route in routes -%}
                {% if loop.first %}routing::{% else %}.{% endif -%}
                {{ route.method|lower }}({{ route.name|snake_case }}::<T>)
            {%- endfor -%}
        )
    {%- endfor -%}
        .layer(Extension(api))
}
