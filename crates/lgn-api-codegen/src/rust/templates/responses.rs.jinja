use lgn_online::{
    server::{Error, Result},
    codegen::{Bytes},
};
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use http::HeaderMap;
use http::HeaderValue;

{% for (path, routes) in api.paths %}
    {% for route in routes %}
        {% let enum_name = "{}Response"|format(route.name|pascal_case) %}

        #[derive(Debug)]
        pub enum {{ enum_name }} {
            {% for (status_code, response) in route.responses -%}
                /// {{ response.description }}
                {% if !response.headers.is_empty() -%}
                    Status{{ status_code }}{
                        {% for (header_name, header) in response.headers -%}
                            {{ header_name|snake_case }}: {{ header.type_|fmt_type(ctx, module_path) }},
                        {% endfor -%}
                        {% if let Some(content) = response.content -%}
                            body: {{ content.type_|fmt_type(ctx, module_path) }},
                        {% endif -%}
                    },
                {% else if let Some(content) = response.content -%}
                    Status{{ status_code }}({{ content.type_|fmt_type(ctx, module_path) }}),
                {% else -%}
                    Status{{ status_code }},
                {% endif -%}
            {% endfor -%}
            WithHeaders(http::HeaderMap, Box<{{ enum_name }}>),
            WithExtensions(http::Extensions, Box<{{ enum_name }}>),
        }

        impl {{ enum_name }} {
            #[must_use]
            pub fn with_headers(self, headers: http::HeaderMap) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut inner_headers, inner) => {
                        inner_headers.extend(headers);
                        Self::WithHeaders(inner_headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_headers(headers)))
                    }
                    s => Self::WithHeaders(headers, Box::new(s))
                }
            }

            #[must_use]
            pub fn with_extensions(self, extensions: http::Extensions) -> Self {
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut inner_extensions, inner) => {
                        inner_extensions.extend(extensions);
                        Self::WithExtensions(inner_extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extensions(extensions)))
                    }
                    s => Self::WithExtensions(extensions, Box::new(s))
                }
            }

            /// Extend this response with the specified header.
            ///
            /// If the header already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_header(self, key: impl http::header::IntoHeaderName, val: http::header::HeaderValue) -> Self {
                // Optimization: if the response chain already contains a
                // `WithHeaders`, we just add the header to the headers
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithHeaders(mut headers, inner) => {
                        headers.insert(key, val);
                        Self::WithHeaders(headers, inner)
                    }
                    Self::WithExtensions(extensions, inner) => {
                        Self::WithExtensions(extensions, Box::new(inner.with_header(key, val)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithHeaders`, so we wrap
                        // the response in a `WithHeaders` and add the
                        // header that way.
                        let mut headers = http::HeaderMap::new();
                        headers.insert(key, val);
                        s.with_headers(headers)
                    }
                }
            }

            /// Extend this response with the specified extension.
            ///
            /// If the extension already existed, it will be overwritten
            /// silently.
            #[must_use]
            pub fn with_extension<T: Send + Sync + 'static>(self, extension: T) -> Self {
                // Optimization: if the response chain already contains a
                // `WithExtensions`, we just add the extension to the extensions
                // map instead of re-boxing the whole thing.
                #[allow(clippy::match_wildcard_for_single_variants)]
                match self {
                    Self::WithExtensions(mut extensions, inner) => {
                        extensions.insert(extension);
                        Self::WithExtensions(extensions, inner)
                    }
                    Self::WithHeaders(headers, inner) => {
                        Self::WithHeaders(headers, Box::new(inner.with_extension(extension)))
                    }
                    s => {
                        // If we get here, we traversed the entire response
                        // chain without finding a `WithExtensions`, so we wrap
                        // the response in a `WithExtensions` and add the
                        // extension that way.
                        let mut extensions = http::Extensions::new();
                        extensions.insert(extension);
                        s.with_extensions(extensions)
                    }
                }
            }

            pub(crate) fn into_response(self) -> Response {
                match self {
                    {% for (status_code, response) in route.responses %}
                        {% if !response.headers.is_empty() -%}
                            Self::Status{{ status_code }}{
                                {% for (header_name, header) in response.headers -%}
                                    {{ header_name|snake_case }},
                                {% endfor -%}
                                {% if let Some(content) = response.content -%}
                                    body,
                                {% endif -%}
                            } => {
                                    {% if let Some(content) = response.content -%}
                                        {% match content.media_type -%}
                                            {% when MediaType::Json -%}
                                                let body = Json(body);
                                            {% when MediaType::Bytes -%}
                                                let body: Vec<u8> = body.into();
                                        {% endmatch -%}
                                    {% else -%}
                                        let body = bytes::Bytes::new();
                                    {% endif -%}
                                    let mut resp = (StatusCode::from_u16({{ status_code.as_u16() }}).unwrap(), body).into_response();
                                    {% for (header_name, header) in response.headers -%}
                                        let {{ header_name|snake_case }}_value = match lgn_online::codegen::encoding::to_percent_encoded_string(&{{ header_name|snake_case }}){
                                            Ok(value) => value,
                                            Err(err) => {
                                                return Error::Internal(format!("failed to serialize header: {{ header_name }}: {}", err)).into_response();
                                            },
                                        };
                                        match HeaderValue::from_str(&{{ header_name|snake_case }}_value){
                                            Ok(value) => resp.headers_mut().insert("{{ header_name }}", value),
                                            Err(err) => {
                                                return Error::Internal(format!("failed to serialize header: {{ header_name }}: {}", err)).into_response();
                                            },
                                        };
                                    {% endfor -%}
                                    resp
                            },
                        {% else if let Some(content) = response.content -%}
                            Self::Status{{ status_code }}(body) => {
                                    {% match content.media_type -%}
                                        {% when MediaType::Json -%}
                                            let body = Json(body);
                                        {% when MediaType::Bytes -%}
                                            let body: Vec<u8> = body.into();
                                    {% endmatch -%}
                                    (StatusCode::from_u16({{ status_code.as_u16() }}).unwrap(), body).into_response()
                            },
                        {%- else -%}
                            Self::Status{{ status_code }} => {
                                StatusCode::from_u16({{ status_code.as_u16() }}).unwrap().into_response()
                            },
                        {%- endif -%}
                    {% endfor %}
                    Self::WithHeaders(headers, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.headers.extend(headers);
                        (parts, body).into_response()
                    }
                    Self::WithExtensions(extensions, inner) => {
                        let (mut parts, body) = inner.into_response().into_parts();
                        parts.extensions.extend(extensions);
                        (parts, body).into_response()
                    }
                }
            }

            pub(crate) async fn from_response<ResBody>(resp: http::Response<ResBody>) -> Result<(http::response::Parts, Self)>
            where
                ResBody: hyper::body::HttpBody,
                ResBody::Error: Into<lgn_online::StdError>,
            {
                let (mut parts, {% if route.has_no_responses_content() %}_{% endif %}body) = resp.into_parts();
                {% if route.responses.is_empty() %}
                    Err(Error::Internal(format!(
                        "unexpected status code: {}",
                        parts.status.as_u16()
                    )))
                {% else %}
                    match parts.status.as_u16() {
                        {% for (status_code, response) in route.responses %}
                            {% let response_name = "{}{}Response"|format(route.name|pascal_case, status_code) %}
                            {{ status_code.as_u16() }} =>
                                {
                                    {%- if !response.headers.is_empty() -%}
                                        {% for (header_name, header) in response.headers -%}
                                            let {{ header_name|snake_case }} = lgn_online::codegen::encoding::from_percent_encoded_string(parts.headers
                                                .remove("{{ header_name }}")
                                                .ok_or_else(|| Error::Internal("missing header: {{ header_name }}".to_owned()))?
                                                .to_str()
                                                .map_err(|e| Error::Internal(format!("invalid header: {{ header_name }}: {}", e)))?)?;
                                        {% endfor -%}

                                        {% if let Some(content) = response.content -%}
                                            let bytes = hyper::body::to_bytes(body).await.map_err(Into::into)?;
                                            let body = {% match content.media_type -%}
                                                            {% when MediaType::Json -%}
                                                                serde_json::from_slice(&bytes)?;
                                                            {% when MediaType::Bytes -%}
                                                                bytes.into();
                                                        {% endmatch -%}
                                        {% endif -%}

                                        Ok((parts, Self::Status{{ status_code }}{
                                            {% for (header_name, header) in response.headers -%}
                                                {{ header_name|snake_case }},
                                            {% endfor -%}
                                            {% if let Some(content) = response.content -%}
                                                body,
                                            {% endif -%}
                                        }))
                                    {%- else if let Some(content) = response.content -%}
                                        let bytes = hyper::body::to_bytes(body).await.map_err(Into::into)?;
                                        let body = {% match content.media_type -%}
                                                        {% when MediaType::Json -%}
                                                            serde_json::from_slice(&bytes)?;
                                                        {% when MediaType::Bytes -%}
                                                            bytes.into();
                                                    {% endmatch -%}
                                        Ok((parts, Self::Status{{ status_code }}(body)))
                                    {%- else -%}
                                        Ok((parts, Self::Status{{ status_code }}))
                                    {%- endif -%}
                                },
                        {%- endfor -%}
                        status => Err(Error::Internal(format!(
                            "unexpected status code: {}",
                            status
                        ))),
                    }
                {% endif %}
            }
        }
    {% endfor %}
{% endfor %}