#ifndef COMMON_HSH
#define COMMON_HSH

#include "crate://lgn-graphics-renderer/gpu/cgen_type/gpu_instance_transform.hlsl"

struct GpuPipelineVertexIn
{
    uint vertexId: SV_VertexID;
    uint instanceId: SV_InstanceID;
    uint va_table_address: INSTANCE0;
};

struct VertexIn {
    float3 pos : POSITION;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;
    float4 color: COLOR;
    float2 uv_coord : TEXCOORD0;
};

float3x3 quaternion_to_matrix(float4 quat)
{
    float3x3 m = float3x3(float3(0, 0, 0), float3(0, 0, 0), float3(0, 0, 0));

    float x = quat.x, y = quat.y, z = quat.z, w = quat.w;
    float x2 = x + x, y2 = y + y, z2 = z + z;
    float xx = x * x2, xy = x * y2, xz = x * z2;
    float yy = y * y2, yz = y * z2, zz = z * z2;
    float wx = w * x2, wy = w * y2, wz = w * z2;

    m[0][0] = 1.0 - (yy + zz);
    m[0][1] = xy - wz;
    m[0][2] = xz + wy;

    m[1][0] = xy + wz;
    m[1][1] = 1.0 - (xx + zz);
    m[1][2] = yz - wx;

    m[2][0] = xz - wy;
    m[2][1] = yz + wx;
    m[2][2] = 1.0 - (xx + yy);

    return m;
}

float3 transform_position(GpuInstanceTransform transform, float3 position) {
    float3 result = transform.scale * position;
    result = mul(quaternion_to_matrix(transform.rotation), result);
    return result + transform.translation;
}

float3 transform_normal(GpuInstanceTransform transform, float3 normal) {
    float3 result = (1.0 / transform.scale) * normal;
    return normalize(mul(quaternion_to_matrix(transform.rotation), result));
}

#endif
