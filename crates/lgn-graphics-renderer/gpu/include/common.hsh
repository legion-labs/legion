#ifndef COMMON_HSH
#define COMMON_HSH

#include "crate://lgn-graphics-renderer/gpu/cgen_type/transform.hlsl"

struct GpuPipelineVertexIn
{
    uint vertexId: SV_VertexID;
    uint instanceId: SV_InstanceID;
    uint va_table_address: INSTANCE0;
};

struct VertexIn {
    float3 pos : POSITION;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;
    float4 color: COLOR;
    float2 uv_coord : TEXCOORD0;
};

float3x3 quaternion_to_matrix(float4 quat)
{
    float3x3 m = float3x3(float3(0, 0, 0), float3(0, 0, 0), float3(0, 0, 0));

    float x = quat.x, y = quat.y, z = quat.z, w = quat.w;
    float x2 = x + x, y2 = y + y, z2 = z + z;
    float xx = x * x2, xy = x * y2, xz = x * z2;
    float yy = y * y2, yz = y * z2, zz = z * z2;
    float wx = w * x2, wy = w * y2, wz = w * z2;

    m[0][0] = 1.0 - (yy + zz);
    m[0][1] = xy - wz;
    m[0][2] = xz + wy;

    m[1][0] = xy + wz;
    m[1][1] = 1.0 - (xx + zz);
    m[1][2] = yz - wx;

    m[2][0] = xz - wy;
    m[2][1] = yz + wx;
    m[2][2] = 1.0 - (xx + yy);

    return m;
}

float3 transform_position(Transform transform, float3 position) {
    float3 result = transform.scale * position;
    result = mul(quaternion_to_matrix(transform.rotation), result);
    return result + transform.translation;
}

float3 transform_position(float4 rotation, float3 translation, float3 position) {
    float3 result = mul(quaternion_to_matrix(rotation), position);
    return result + translation;
}

float3 transform_normal(Transform transform, float3 normal) {
    float3 result = (1.0 / transform.scale) * normal;
    return normalize(mul(quaternion_to_matrix(transform.rotation), result));
}

float3 transform_normal(float4 rotation, float3 normal) {
    return normalize(mul(quaternion_to_matrix(rotation), normal));
} 

// See https://github.com/emilk/egui/blob/26d576f5101dfa1219f79bf9c99e29c577487cd3/egui_glium/src/painter.rs#L19.
float3 linear_from_srgb(float3 srgb) {
    bool3 cutoff = srgb < float3(10.31475, 10.31475, 10.31475);
    float3 lower = srgb / float3(3294.6, 3294.6, 3294.6);
    float3 higher = pow((srgb + float3(14.025, 14.025, 14.025)) / float3(269.025, 269.025, 269.025), float3(2.4, 2.4, 2.4));
    return lerp(higher, lower, cutoff);
}

float4 linear_from_srgba(float4 srgba) {
    return float4(linear_from_srgb(srgba.rgb), srgba.a / 255.0);
}

float4 unpack_srgb(uint packed_color) {
    return float4(
        (packed_color & 0x000000FF) / 255.0,
        ((packed_color & 0x0000FF00) >> 8) / 255.0,
        ((packed_color & 0x00FF0000) >> 16) / 255.0,
        ((packed_color & 0xFF000000) >> 24) / 255.0
    );
}

float4 unpack_linear(uint packed_color) {
    float4 srgba = float4(
        (packed_color & 0x000000FF),
        ((packed_color & 0x0000FF00) >> 8),
        ((packed_color & 0x00FF0000) >> 16),
        ((packed_color & 0xFF000000) >> 24)
    );
    return linear_from_srgba(srgba);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// https://en.wikipedia.org/wiki/SRGB
float linear2srgb_std(float value) {
    return (value <= 0.0031308f) ? (12.92f * value) : (1.055f * pow(value, 1.0f / 2.4f) - 0.055f);
}

float3 linear2srgb(float3 value)
{
#if 0
    return pow(value, 1.0f/2.2f);
#else
    return float3(linear2srgb_std(value.r), linear2srgb_std(value.g), linear2srgb_std(value.b));
#endif
}

// https://en.wikipedia.org/wiki/SRGB
// putting the reciprocal here for now until we move color utilities to a header
float srgb2linear_std(float value) {
    return (value <= 0.04045f) ? (value / 12.92f) : pow((value + 0.055f) / 1.055f, 2.4f);
}

float3 srgb2linear(float3 value)
{
#if 0
    return pow(value, 2.2f);
#else
    return float3(srgb2linear_std(value.r), srgb2linear_std(value.g), srgb2linear_std(value.b));
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const float3x3 ACESInputMat =
{
    {0.59719, 0.35458, 0.04823},
    {0.07600, 0.90834, 0.01566},
    {0.02840, 0.13383, 0.83777}
};

// ODT_SAT => XYZ => D60_2_D65 => sRGB
static const float3x3 ACESOutputMat =
{
    { 1.60475, -0.53108, -0.07367},
    {-0.10208,  1.10813, -0.00605},
    {-0.00327, -0.07276,  1.07602}
};

float3 RRTAndODTFit(float3 v)
{
    float3 a = v * (v + 0.0245786f) - 0.000090537f;
    float3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
    return a / b;
}

float3 ACESFitted(float3 color)
{
    color = mul(ACESInputMat, color);

    // Apply RRT and ODT
    color = RRTAndODTFit(color);

    color = mul(ACESOutputMat, color);

    // Clamp to [0, 1]
    color = saturate(color);

    return color;
}

float3 tonemap(float3 value) {
    // place holder
    return ACESFitted(value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif
