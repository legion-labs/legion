{
  "script": "\nuse lgn_math::{normalize2, random};\n\nconst VELOCITY = 0.7;\n\nstruct Vec2 {\n    x,\n    y,\n}\n\npub fn update(entity, last_result, entities) {\n    let ball_direction = if last_result is unit {\n        let v = Vec2 {\n            x: random() - 0.5,\n            y: random() - 0.5,\n        };\n        if let (vx, vy) = normalize2(v.x, v.y) {\n            v.x = vx * 0.1;\n            v.y = vy * 0.1;\n        }\n        v\n    } else {\n        last_result\n    };\n\n    let position = entity.transform.translation;\n\n    if position.x < -3.0 || position.x > 3.0 {\n        ball_direction.x = -ball_direction.x;\n    }\n    if position.y < -2.0 || position.y > 2.0 {\n        ball_direction.y = -ball_direction.y;\n    }\n\n    position.clamp_x(-3.0, 3.0);\n    position.clamp_y(-2.0, 2.0);\n\n    // update paddles\n    let left_paddle = 0.0;\n    if let Some(entity) = entities[\"Pad Left\"] {\n        left_paddle = entity.transform.translation.y;\n    }\n    let right_paddle = 0.0;\n    if let Some(entity) = entities[\"Pad Right\"] {\n        right_paddle = entity.transform.translation.y;\n    }\n    println!(\"paddles: {}, {}\", left_paddle, right_paddle);\n\n    // check for collision with paddles (dimensions = 0.2 x 1.0 x 0.2)\n    // Note: x-axis is inverted so values decrease towards the right\n    let new_position = Vec2 {\n        x: position.x + VELOCITY * ball_direction.x,\n        y: position.y + VELOCITY * ball_direction.y,\n    };\n\n    position.x += VELOCITY * ball_direction.x;\n    position.y += VELOCITY * ball_direction.y;\n\n    ball_direction\n}",
  "script_type": "Rune"
}