//! This module provides interop types between the `gRPC` protocol and the types used in the
//! Javascript frontend.
//!
//! Most of the structures here are 1:1 mappings of the `gRPC` protocol ones, which at first could
//! seem like a non-sensical thing.
//!
//! Note however that:
//!
//! - The `gRPC` generated types are not JSON serializable/deserializable and we can't just
//! implement the `serde` traits on them.
//! - The two protocols: one between the Javascript and the native Tauri client and the other
//! between the native Tauri client and the Editor server **do not have to be the same**. They can
//! be, but that's not mandatory. Actually, we could totally imagine a case where the Javascript
//! needs some extra fields or a different layout from the one generated by `gRPC` for its
//! implementation to be maintainable or effective. Just because it's not the case right now
//! doesn't mean it will always be like that. That abstraction protects us from that.
//!
//! In any case, maintaining the mappings below should not be a huge burden and very straighforward
//! in most cases.

use legion_editor_proto::{
    GetResourcePropertiesRequest, GetResourcePropertiesResponse, ResourceDescription,
    ResourceProperty, ResourcePropertyUpdate, SearchResourcesRequest,
    UpdateResourcePropertiesRequest, UpdateResourcePropertiesResponse,
};
use serde::{Deserialize, Serialize};

pub trait IntoVec<T> {
    fn into_vec(self) -> Vec<T>;
}

impl<F, T> IntoVec<T> for Vec<F>
where
    F: Into<T>,
{
    fn into_vec(self) -> Vec<T> {
        self.into_iter().map(Into::into).collect()
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSSearchResourcesRequest {
    pub search_token: String,
}

impl From<SearchResourcesRequest> for JSSearchResourcesRequest {
    fn from(v: SearchResourcesRequest) -> Self {
        Self {
            search_token: v.search_token,
        }
    }
}

impl From<JSSearchResourcesRequest> for SearchResourcesRequest {
    fn from(v: JSSearchResourcesRequest) -> Self {
        Self {
            search_token: v.search_token,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSSearchResourcesResponse {
    pub resource_descriptions: Vec<JSResourceDescription>,
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSUndoTransactionResponse {
    pub transaction_id: i32,
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSRedoTransactionResponse {
    pub transaction_id: i32,
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSGetResourcePropertiesRequest {
    pub id: String,
}

impl From<GetResourcePropertiesRequest> for JSGetResourcePropertiesRequest {
    fn from(v: GetResourcePropertiesRequest) -> Self {
        Self { id: v.id }
    }
}

impl From<JSGetResourcePropertiesRequest> for GetResourcePropertiesRequest {
    fn from(v: JSGetResourcePropertiesRequest) -> Self {
        Self { id: v.id }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSGetResourcePropertiesResponse {
    pub description: JSResourceDescription,
    pub properties: Vec<JSResourceProperty>,
}

impl From<GetResourcePropertiesResponse> for JSGetResourcePropertiesResponse {
    fn from(v: GetResourcePropertiesResponse) -> Self {
        Self {
            description: v.description.unwrap_or_default().into(),
            properties: v.properties.into_vec(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSResourceDescription {
    pub id: String,
    pub path: String,
    pub version: u32,
}

impl From<ResourceDescription> for JSResourceDescription {
    fn from(v: ResourceDescription) -> Self {
        Self {
            id: v.id,
            path: v.path,
            version: v.version,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSResourceProperty {
    pub name: String,
    pub ptype: String,
    pub default_value: String, // JSON string
    pub value: String,         // JSON string
    pub group: String,
}

impl From<ResourceProperty> for JSResourceProperty {
    fn from(v: ResourceProperty) -> Self {
        Self {
            name: v.name,
            ptype: v.ptype,
            default_value: String::from_utf8(v.default_value)
                .expect("invalid utf-8 string for default value"),
            value: String::from_utf8(v.value).expect("invalid utf-8 string for value"),
            group: v.group,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSResourcePropertyUpdate {
    pub name: String,
    pub value: String, // JSON string
}

impl From<ResourcePropertyUpdate> for JSResourcePropertyUpdate {
    fn from(v: ResourcePropertyUpdate) -> Self {
        Self {
            name: v.name,
            value: String::from_utf8(v.value).expect("invalid utf-8 string for value"),
        }
    }
}

impl From<JSResourcePropertyUpdate> for ResourcePropertyUpdate {
    fn from(val: JSResourcePropertyUpdate) -> Self {
        Self {
            name: val.name,
            value: val.value.as_bytes().to_vec(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSUpdateResourcePropertiesRequest {
    pub id: String,
    pub version: u32,
    pub property_updates: Vec<JSResourcePropertyUpdate>,
}

impl From<UpdateResourcePropertiesRequest> for JSUpdateResourcePropertiesRequest {
    fn from(v: UpdateResourcePropertiesRequest) -> Self {
        Self {
            id: v.id,
            version: v.version,
            property_updates: v.property_updates.into_vec(),
        }
    }
}

impl From<JSUpdateResourcePropertiesRequest> for UpdateResourcePropertiesRequest {
    fn from(val: JSUpdateResourcePropertiesRequest) -> Self {
        Self {
            id: val.id,
            version: val.version,
            property_updates: val.property_updates.into_vec(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSUpdateResourcePropertiesResponse {
    pub version: u32,
    pub updated_properties: Vec<JSResourcePropertyUpdate>,
}

impl From<UpdateResourcePropertiesResponse> for JSUpdateResourcePropertiesResponse {
    fn from(v: UpdateResourcePropertiesResponse) -> Self {
        Self {
            version: v.version,
            updated_properties: v.updated_properties.into_vec(),
        }
    }
}
