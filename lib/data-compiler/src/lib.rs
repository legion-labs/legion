//! A crate with modules supporting data compilation process.
//!
//! * [`compiler_api`] provides an interface for implementing a data compiler.
//! * [`compiler_cmd`] provides utilities for interacting with data compilers.

// BEGIN - Legion Labs lints v0.3
// do not change or add/remove here, but one can add exceptions after this section
#![warn(
    clippy::all,
    clippy::await_holding_lock,
    clippy::char_lit_as_u8,
    clippy::checked_conversions,
    clippy::dbg_macro,
    clippy::debug_assert_with_mut_call,
    clippy::doc_markdown,
    clippy::empty_enum,
    clippy::enum_glob_use,
    clippy::exit,
    clippy::expl_impl_clone_on_copy,
    clippy::explicit_deref_methods,
    clippy::explicit_into_iter_loop,
    clippy::fallible_impl_from,
    clippy::filter_map_next,
    clippy::float_cmp_const,
    clippy::fn_params_excessive_bools,
    clippy::if_let_mutex,
    clippy::implicit_clone,
    clippy::imprecise_flops,
    clippy::inefficient_to_string,
    clippy::invalid_upcast_comparisons,
    clippy::large_types_passed_by_value,
    clippy::let_unit_value,
    clippy::linkedlist,
    clippy::lossy_float_literal,
    clippy::macro_use_imports,
    clippy::manual_ok_or,
    clippy::map_err_ignore,
    clippy::map_flatten,
    clippy::map_unwrap_or,
    clippy::match_on_vec_items,
    clippy::match_same_arms,
    clippy::match_wildcard_for_single_variants,
    clippy::mem_forget,
    clippy::mismatched_target_os,
    clippy::mut_mut,
    clippy::mutex_integer,
    clippy::needless_borrow,
    clippy::needless_continue,
    clippy::needless_pass_by_value,
    clippy::option_option,
    clippy::path_buf_push_overwrite,
    clippy::ptr_as_ptr,
    clippy::ref_option_ref,
    clippy::rest_pat_in_fully_bound_structs,
    clippy::same_functions_in_if_condition,
    clippy::semicolon_if_nothing_returned,
    clippy::string_add_assign,
    clippy::string_lit_as_bytes,
    clippy::string_to_string,
    clippy::todo,
    clippy::trait_duplication_in_bounds,
    clippy::unimplemented,
    clippy::unnested_or_patterns,
    clippy::unused_self,
    clippy::useless_transmute,
    clippy::use_self,
    clippy::verbose_file_reads,
    clippy::zero_sized_map_values,
    future_incompatible,
    nonstandard_style,
    rust_2018_idioms,
    rustdoc::private_intra_doc_links,
    rustdoc::missing_crate_level_docs,
    rustdoc::broken_intra_doc_links
)]
// END - Legion Labs standard lints v0.3
// crate-specific exceptions:
#![allow()]
#![warn(missing_docs)]

use core::fmt;
use std::{num::ParseIntError, str::FromStr};

use legion_data_offline::asset::AssetPathId;
use serde::{Deserialize, Serialize};

/// Identifies a group of outputs generated by the data compiler.
#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize, Hash)]
pub struct CompilerHash(pub u64);

/// Description of a compiled resource.
#[derive(Debug, PartialEq, Eq, Serialize, Deserialize, Clone)]
pub struct CompiledResource {
    /// The path of derived resource.
    pub path: AssetPathId,
    /// The checksum of the resource.
    pub checksum: i128,
    /// The size of the resource.
    pub size: usize,
}

impl fmt::Display for CompiledResource {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "{}-{}-{}",
            self.checksum, self.size, self.path
        ))
    }
}

impl FromStr for CompiledResource {
    type Err = ParseIntError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let err = "Z".parse::<i32>().expect_err("ParseIntError");
        let mut iter = s.split(|c| c == '-');

        let checksum = i128::from_str(iter.next().ok_or_else(|| err.clone())?)?;
        let size = usize::from_str(iter.next().ok_or_else(|| err.clone())?)?;
        let path = AssetPathId::from_str(iter.next().ok_or(err)?)?;
        Ok(Self {
            path,
            checksum,
            size,
        })
    }
}

/// The output of data compilation.
///
/// `Manifest` contains the list of compiled resources.
#[derive(Debug, Serialize, Deserialize, Default)]
pub struct Manifest {
    /// The description of all compiled resources.
    pub compiled_resources: Vec<CompiledResource>,
}

/// Build target enumeration.
///
/// `TODO`: This needs to be more extensible.
#[derive(Clone, Copy)]
pub enum Target {
    /// Game client.
    Game,
    /// Server.
    Server,
    /// Backend service.
    Backend,
}

impl fmt::Display for Target {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Target::Game => write!(f, "game"),
            Target::Server => write!(f, "server"),
            Target::Backend => write!(f, "backend"),
        }
    }
}

impl FromStr for Target {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "game" => Ok(Self::Game),
            "server" => Ok(Self::Server),
            "backend" => Ok(Self::Backend),
            _ => Err(()),
        }
    }
}

/// Build platform enumeration.
#[derive(Clone, Copy)]
pub enum Platform {
    /// Windows
    Windows,
    /// Unix
    Unix,
    /// Game Console X
    ConsoleX,
}

impl fmt::Display for Platform {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Platform::Windows => write!(f, "windows"),
            Platform::Unix => write!(f, "unix"),
            Platform::ConsoleX => write!(f, "consolex"),
        }
    }
}

impl FromStr for Platform {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "windows" => Ok(Self::Windows),
            "unix" => Ok(Self::Unix),
            "consolex" => Ok(Self::ConsoleX),
            _ => Err(()),
        }
    }
}

/// Defines user's language/region.
pub struct Locale(String);

impl Locale {
    /// Creates a new Locale.
    pub fn new(v: &str) -> Self {
        Self(String::from(v))
    }
}

pub mod compiler_api;
pub mod compiler_cmd;
pub mod compiler_utils;
