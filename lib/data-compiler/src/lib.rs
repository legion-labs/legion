//! A crate with modules supporting data compilation process.
//!
//! * [`compiler_api`] provides an interface for implementing a data compiler.
//! * [`compiler_cmd`] provides utilities for interacting with data compilers.

// BEGIN - Legion Labs lints v0.6
// do not change or add/remove here, but one can add exceptions after this section
#![deny(unsafe_code)]
#![warn(future_incompatible, nonstandard_style, rust_2018_idioms)]
// Rustdoc lints
#![warn(
    rustdoc::broken_intra_doc_links,
    rustdoc::missing_crate_level_docs,
    rustdoc::private_intra_doc_links
)]
// Clippy pedantic lints, treat all as warnings by default, add exceptions in allow list
#![warn(clippy::pedantic)]
#![allow(
    clippy::cast_possible_truncation,
    clippy::cast_sign_loss,
    clippy::if_not_else,
    clippy::items_after_statements,
    clippy::missing_panics_doc,
    clippy::module_name_repetitions,
    clippy::must_use_candidate,
    clippy::similar_names,
    clippy::shadow_unrelated,
    clippy::unreadable_literal,
    clippy::unseparated_literal_suffix
)]
// Clippy nursery lints, still under development
#![warn(
    clippy::debug_assert_with_mut_call,
    clippy::disallowed_method,
    clippy::disallowed_type,
    clippy::fallible_impl_from,
    clippy::imprecise_flops,
    clippy::mutex_integer,
    clippy::path_buf_push_overwrite,
    clippy::string_lit_as_bytes,
    clippy::use_self,
    clippy::useless_transmute
)]
// Clippy restriction lints, usually not considered bad, but useful in specific cases
#![warn(
    clippy::dbg_macro,
    clippy::exit,
    clippy::float_cmp_const,
    clippy::map_err_ignore,
    clippy::mem_forget,
    clippy::missing_enforced_import_renames,
    clippy::rest_pat_in_fully_bound_structs,
    clippy::string_to_string,
    clippy::todo,
    clippy::unimplemented,
    clippy::verbose_file_reads
)]
// END - Legion Labs lints v0.6
// crate-specific exceptions:
#![allow(unsafe_code, clippy::missing_errors_doc)]
#![warn(missing_docs)]

use core::fmt;
use std::str::FromStr;

use legion_content_store::Checksum;
use legion_data_offline::ResourcePathId;
use serde::{Deserialize, Serialize};

/// Identifies a group of outputs generated by the data compiler.
#[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize, Deserialize, Hash)]
pub struct CompilerHash(pub u64);

/// Description of a compiled resource.
#[derive(Debug, PartialEq, Eq, Serialize, Deserialize, Clone)]
pub struct CompiledResource {
    /// The path of derived resource.
    pub path: ResourcePathId,
    /// The checksum of the resource.
    pub checksum: Checksum,
    /// The size of the resource.
    pub size: usize,
}

impl fmt::Display for CompiledResource {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "{}-{}-{}",
            self.checksum, self.size, self.path
        ))
    }
}

impl FromStr for CompiledResource {
    type Err = Box<dyn std::error::Error>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let err = "Z".parse::<i32>().expect_err("ParseIntError");
        let mut iter = s.split(|c| c == '-');

        let checksum = Checksum::from_str(iter.next().ok_or_else(|| err.clone())?)?;
        let size = usize::from_str(iter.next().ok_or_else(|| err.clone())?)?;
        let data_iter = iter.next().unwrap();
        let data_idx = unsafe { data_iter.as_ptr().offset_from(s.as_ptr()) } as usize;
        let path = ResourcePathId::from_str(&s[data_idx..])?;
        Ok(Self {
            path,
            checksum,
            size,
        })
    }
}

/// The output of data compilation.
///
/// `Manifest` contains the list of compiled resources.
#[derive(Debug, Serialize, Deserialize, Default)]
pub struct Manifest {
    /// The description of all compiled resources.
    pub compiled_resources: Vec<CompiledResource>,
}

impl Manifest {
    /// Prepare manifest for serialization.
    /// Will sort contents to guarantee that the serialization is deterministic
    pub fn pre_serialize(&mut self) {
        self.compiled_resources.sort_by(|a, b| a.path.cmp(&b.path));
    }

    /// Creates a runtime [`legion_data_runtime::manifest::Manifest`] from an offline [`Manifest`].
    ///
    /// Provided filter functor will be used to determine if a given asset should be included in the manifest.
    ///
    /// This is a temporary solution that will be replaced by a **packaging** process.
    /// For now, we simply create a runtime manifest by filtering out non-asset resources
    /// and by identifying content by `ResourceId` - which runtime operates on.
    pub fn into_rt_manifest(
        self,
        filter: fn(&ResourcePathId) -> bool,
    ) -> legion_data_runtime::manifest::Manifest {
        let mut output = legion_data_runtime::manifest::Manifest::default();

        let runtime_resources = self
            .compiled_resources
            .into_iter()
            .filter(|resource| filter(&resource.path))
            .collect::<Vec<_>>();

        for resource in runtime_resources {
            output.insert(
                resource.path.resource_id(),
                resource.checksum,
                resource.size,
            );
        }
        output
    }
}

/// Build target enumeration.
///
/// `TODO`: This needs to be more extensible.
#[derive(Clone, Copy)]
pub enum Target {
    /// Game client.
    Game,
    /// Server.
    Server,
    /// Backend service.
    Backend,
}

impl fmt::Display for Target {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Target::Game => write!(f, "game"),
            Target::Server => write!(f, "server"),
            Target::Backend => write!(f, "backend"),
        }
    }
}

impl FromStr for Target {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "game" => Ok(Self::Game),
            "server" => Ok(Self::Server),
            "backend" => Ok(Self::Backend),
            _ => Err(()),
        }
    }
}

/// Build platform enumeration.
#[derive(Clone, Copy)]
pub enum Platform {
    /// Windows
    Windows,
    /// Unix
    Unix,
    /// Game Console X
    ConsoleX,
}

impl fmt::Display for Platform {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Platform::Windows => write!(f, "windows"),
            Platform::Unix => write!(f, "unix"),
            Platform::ConsoleX => write!(f, "consolex"),
        }
    }
}

impl FromStr for Platform {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "windows" => Ok(Self::Windows),
            "unix" => Ok(Self::Unix),
            "consolex" => Ok(Self::ConsoleX),
            _ => Err(()),
        }
    }
}

/// Defines user's language/region.
pub struct Locale(String);

impl Locale {
    /// Creates a new Locale.
    pub fn new(v: &str) -> Self {
        Self(String::from(v))
    }
}

pub mod compiler_api;
pub mod compiler_cmd;
pub mod compiler_utils;
